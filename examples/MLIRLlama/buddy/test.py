from mlir import ir
from mlir.dialects import tosa, linalg, arith, tensor, math
import numpy
from mlir.passmanager import PassManager

ctx = ir.Context()
with ir.Location.unknown(ctx):
  _module = ir.Module.create()
  with ir.InsertionPoint(_module.body):
      op2 = tensor.EmptyOp([1, 13], ir.IntegerType.get_signless(1))
      print(op2)
      op3 = tensor.EmptyOp([1, 13], ir.F32Type.get())
      print(str(ir.RankedTensorType(op2.result.type).element_type)=="i1")
      op4 = arith.ExtUIOp(ir.RankedTensorType.get([1, 13], ir.IntegerType.get_signless(32)), op2.result)
      op4 = arith.BitcastOp(ir.RankedTensorType.get([1, 13], ir.F32Type.get()), op4.result)
      tensor_type = ir.RankedTensorType.get([1, 13], ir.F32Type.get())
      output_shape = [1, 13]
      generic_map = ir.AffineMap.get_permutation([i for i in range(len(output_shape))])
      print(ir.AffineMap.get(2, 0, [ir.AffineAddExpr.get(ir.AffineExpr.get_dim(0), ir.AffineExpr.get_constant(64))]))
      op = linalg.GenericOp([tensor_type], [], [op4],
                            ir.ArrayAttr.get([ir.AffineMapAttr.get(generic_map.get_submap([i for i in range(len(output_shape))]))]),
                            ir.ArrayAttr.get([ir.Attribute.parse('#linalg.iterator_type<parallel>')]*len(output_shape)))
      block = ir.Block.create_at_start(op.region, [ir.RankedTensorType(op4.result.type).element_type])
      block.append(linalg.YieldOp([block.arguments[0]]))
      op = math.RsqrtOp(op4.result)
      tensor_type = ir.RankedTensorType.get([13, 1], ir.F32Type.get())
      output = tensor.EmptyOp([13, 1], ir.F32Type.get())
      # op4 = tensor.EmptyOp([1, 1], ir.F32Type.get())
      # op = linalg.ReduceOp([ir.RankedTensorType.get([1, 1], ir.F32Type.get())], [op3.result], [op4.result], ir._denseI64ArrayAttr([1], ctx))
      # block = ir.Block.create_at_start(op.regions[0], [ir.RankedTensorType(op3.result.type).element_type, ir.RankedTensorType(op4.result.type).element_type])
      #fpowi_op = arith.AddFOp(block.arguments[0], block.arguments[1])
      #block.append(fpowi_op)
      #block.append(linalg.YieldOp([fpowi_op.result]))
  print(_module)
  pm = PassManager("builtin.module")
  pm.add("func.func(tosa-to-linalg)")
  pm.add("func.func(tosa-to-tensor)")
  pm.add("func.func(tosa-to-arith)")
  pm.add("empty-tensor-to-alloc-tensor")
  pm.add("convert-elementwise-to-linalg")
  pm.add("arith-bufferize")
  pm.add("func.func(linalg-bufferize)")
  pm.add("func.func(tensor-bufferize)")
  pm.add("func-bufferize")
  pm.run(_module.operation)
  print(_module)
  print("-------------------------------------------------------------------")
  print("Lowering the module to LLVM dialect ...")
  pm.add("func.func(buffer-deallocation)")
  pm.add("func.func(convert-linalg-to-loops)")
  pm.add("convert-scf-to-cf")
  pm.add("convert-linalg-to-llvm")
  pm.add("convert-arith-to-llvm")
  pm.add("expand-strided-metadata")
  pm.add("finalize-memref-to-llvm")
  pm.add("convert-func-to-llvm")
  pm.add("reconcile-unrealized-casts")
  pm.run(_module.operation)
  print(_module)