from mlir import ir
from mlir.dialects import tosa, linalg, arith, tensor
import numpy
from mlir.passmanager import PassManager

ctx = ir.Context()
with ir.Location.unknown(ctx):
  _module = ir.Module.create()
  with ir.InsertionPoint(_module.body):
      op2 = tensor.EmptyOp([1, 13], ir.IntegerType.get_signless(1))
      print(op2)
      op3 = tensor.EmptyOp([1, 13], ir.F32Type.get())
      print(str(ir.RankedTensorType(op2.result.type).element_type)=="i1")
      op4 = arith.ExtUIOp(ir.RankedTensorType.get([1, 13], ir.IntegerType.get_signless(32)), op2.result)
      op4 = arith.BitcastOp(ir.RankedTensorType.get([1, 13], ir.F32Type.get()), op4.result)
      print(op4)
      value = 1.0
      value = arith.ConstantOp(ir.F32Type.get(), ir.FloatAttr.get(ir.F32Type.get(), value))
      print(value)
  print(_module)
  pm = PassManager("builtin.module")
  pm.add("func.func(tosa-to-linalg)")
  pm.add("func.func(tosa-to-tensor)")
  pm.add("func.func(tosa-to-arith)")
  pm.add("empty-tensor-to-alloc-tensor")
  pm.add("convert-elementwise-to-linalg")
  pm.add("arith-bufferize")
  pm.add("func.func(linalg-bufferize)")
  pm.add("func.func(tensor-bufferize)")
  pm.add("func-bufferize")
  pm.run(_module.operation)
  print(_module)
  print("-------------------------------------------------------------------")
  print("Lowering the module to LLVM dialect ...")
  pm.add("func.func(buffer-deallocation)")
  pm.add("func.func(convert-linalg-to-loops)")
  pm.add("convert-scf-to-cf")
  pm.add("convert-linalg-to-llvm")
  pm.add("convert-arith-to-llvm")
  pm.add("expand-strided-metadata")
  pm.add("finalize-memref-to-llvm")
  pm.add("convert-func-to-llvm")
  pm.add("reconcile-unrealized-casts")
  pm.run(_module.operation)
  print(_module)