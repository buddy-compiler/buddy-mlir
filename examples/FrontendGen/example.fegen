<<<<<<< HEAD
module
grammar [funDefine+]

funDefine
inputs [attributeValue<string>, attributeValue<toy.functionType>]
// regions []
grammar [prototype block]
ir [operation<toy.func>]

prototype
grammar [Def funcName funcParams]

funcName
returns [attributeValue<SymbolNameAttr> name = $Identifier.text]
grammar [Identifier]

funcParams
inputs [list<cppValue<"Type">> x]
returns [attributeValue<toy.functionType> v]
grammar [ParentheseOpen declList? ParentheseClose]
ir [attribute<toy.functionType>]

declList
grammar [varDecl (Comma varDecl)*]

varDecl
returns [cppValue<"Type">]{
    // code to get cppValue
}
grammar [
    Var Identifier (type)? (Equal expression)? |
    Identifier Identifier (Equal expression)? |
    Identifier
    ]

block
grammar [BracketOpen (blockExpr Semicolon)* BracketClose]

blockExpr
grammar [varDecl | returnExpr | expression]

Identifier
grammar [[a-z]*]

ParentheseOpen
grammar ['(']
=======
fegen toy

typedef struct {
    parameters [list<Type> elementTypes]
}

Type Toy_Type = any<[tensor, struct]>;

opdef constant {
    arguments [attribute double numberAttr]
    results [operand Tensor res]
    body {
        list<int> shape = shapeOf(res);
        // full是一个内置函数，创建memref，并将每个元素都填充numberAttr
        res = full(shape, numberAttr);    
    }
}

opdef add {
    arguments [operand Tensor lhs, operand Tensor rhs]
    results [operand Tensor res]
    body {
        // 这个'+'也是一个内置的函数
        res = lhs + rhs;
    }
}

opdef mul {
    arguments [operand Tensor lhs, operand Tensor rhs]
    results [operand Tensor res]
    body {
        // 这个'*'也是一个内置的函数
        res = lhs * rhs;
    }
}

opdef reshape {
    arguments [operand F64Tensor input]
    results [operand F64Tensor output]
    body {
        list<int> shape = shapeOf(output);
        output = reshape(input, shape);
    }
}

double stod(string numStr){
    double res = 0;
    int index;
    int i;
    for(i = 0; i <= len(numStr)-1; i=i+1){
        char c = numStr[0];
        int charNum;
        if(c == '0'){
            charNum = 0;
        }else if (c == '1'){
            charNum = 1;
        }else if (c == '2'){
            charNum = 2;
        }else if (c == '3'){
            charNum = 3;
        }else if (c == '4'){
            charNum = 4;
        }else if (c == '5'){
            charNum = 5;
        }else if (c == '6'){
            charNum = 6;
        }else if (c == '7'){
            charNum = 7;
        }else if (c == '8'){
            charNum = 8;
        }else if (c == '9'){
            charNum = 9;
        }else if (c == '.'){
            index = i;
        }
        res = res * 10;
        res = res + charNum;    
    }
    res = res * 0.1**(len(numStr) - 1 - index);
    return res;
}
>>>>>>> 8cb8a2b9eb8a15bf99280049e7f321d3114fb4bc

ParentheseClose
grammar [')']

<<<<<<< HEAD
Comma
grammar [',']

Var
grammar ['var']
=======
module
    : structDefine* funDefine+
    ;

structDefine
    : Struct Identifier BracketOpen (varDecl Semicolon)* BracketClose
    ;

// cpp value --get--> mlir::attribute || --constant Operation--> mlir::Value
//           ========                 ||

expression
    : Number
    {   returns [operand F64Tensor ret, operand F64Tensor ret]
        actions {
            // Type  mlir::Value  ret of operator | Attribute | Cpp Value
            double numberAttr = stod($Number().getText());
            Type retType = Tensor<[], double>;
            ret = constant(numberAttr, retType);
        }
    }
    ;
>>>>>>> 8cb8a2b9eb8a15bf99280049e7f321d3114fb4bc
