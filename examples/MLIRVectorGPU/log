// -----// IR Dump Before LinalgLowerToLoops (convert-linalg-to-loops) //----- //
module attributes {gpu.container_module} {
  gpu.module @kernels {
    gpu.func @vector_constant_mask(%arg0: memref<4x3xi1>) kernel {
      %c0 = arith.constant 0 : index
      %0 = vector.constant_mask [3, 2] : vector<4x3xi1>
      vector.store %0, %arg0[%c0, %c0] : memref<4x3xi1>, vector<4x3xi1>
      gpu.return
    }
  }
  func.func @main() {
    %alloc = memref.alloc() : memref<4x3xi1>
    %cast = memref.cast %alloc : memref<4x3xi1> to memref<*xi1>
    %c1 = arith.constant 1 : index
    gpu.host_register %cast : memref<*xi1>
    gpu.launch_func  @kernels::@vector_constant_mask blocks in (%c1, %c1, %c1) threads in (%c1, %c1, %c1)  args(%alloc : memref<4x3xi1>)
    %cast_0 = memref.cast %alloc : memref<4x3xi1> to memref<*xi1>
    call @printMemrefI32(%cast) : (memref<*xi1>) -> ()
    return
  }
  func.func private @printMemrefI32(memref<*xi1>)
}


// -----// IR Dump Before ConvertVectorToSCF (convert-vector-to-scf) //----- //
module attributes {gpu.container_module} {
  gpu.module @kernels {
    gpu.func @vector_constant_mask(%arg0: memref<4x3xi1>) kernel {
      %c0 = arith.constant 0 : index
      %0 = vector.constant_mask [3, 2] : vector<4x3xi1>
      vector.store %0, %arg0[%c0, %c0] : memref<4x3xi1>, vector<4x3xi1>
      gpu.return
    }
  }
  func.func @main() {
    %c1 = arith.constant 1 : index
    %alloc = memref.alloc() : memref<4x3xi1>
    %cast = memref.cast %alloc : memref<4x3xi1> to memref<*xi1>
    gpu.host_register %cast : memref<*xi1>
    gpu.launch_func  @kernels::@vector_constant_mask blocks in (%c1, %c1, %c1) threads in (%c1, %c1, %c1)  args(%alloc : memref<4x3xi1>)
    call @printMemrefI32(%cast) : (memref<*xi1>) -> ()
    return
  }
  func.func private @printMemrefI32(memref<*xi1>)
}


// -----// IR Dump Before ConvertAffineToStandard (lower-affine) //----- //
module attributes {gpu.container_module} {
  gpu.module @kernels {
    gpu.func @vector_constant_mask(%arg0: memref<4x3xi1>) kernel {
      %c0 = arith.constant 0 : index
      %0 = vector.constant_mask [3, 2] : vector<4x3xi1>
      vector.store %0, %arg0[%c0, %c0] : memref<4x3xi1>, vector<4x3xi1>
      gpu.return
    }
  }
  func.func @main() {
    %c1 = arith.constant 1 : index
    %alloc = memref.alloc() : memref<4x3xi1>
    %cast = memref.cast %alloc : memref<4x3xi1> to memref<*xi1>
    gpu.host_register %cast : memref<*xi1>
    gpu.launch_func  @kernels::@vector_constant_mask blocks in (%c1, %c1, %c1) threads in (%c1, %c1, %c1)  args(%alloc : memref<4x3xi1>)
    call @printMemrefI32(%cast) : (memref<*xi1>) -> ()
    return
  }
  func.func private @printMemrefI32(memref<*xi1>)
}


// -----// IR Dump Before SCFToControlFlow (convert-scf-to-cf) //----- //
module attributes {gpu.container_module} {
  gpu.module @kernels {
    gpu.func @vector_constant_mask(%arg0: memref<4x3xi1>) kernel {
      %c0 = arith.constant 0 : index
      %0 = vector.constant_mask [3, 2] : vector<4x3xi1>
      vector.store %0, %arg0[%c0, %c0] : memref<4x3xi1>, vector<4x3xi1>
      gpu.return
    }
  }
  func.func @main() {
    %c1 = arith.constant 1 : index
    %alloc = memref.alloc() : memref<4x3xi1>
    %cast = memref.cast %alloc : memref<4x3xi1> to memref<*xi1>
    gpu.host_register %cast : memref<*xi1>
    gpu.launch_func  @kernels::@vector_constant_mask blocks in (%c1, %c1, %c1) threads in (%c1, %c1, %c1)  args(%alloc : memref<4x3xi1>)
    call @printMemrefI32(%cast) : (memref<*xi1>) -> ()
    return
  }
  func.func private @printMemrefI32(memref<*xi1>)
}


// -----// IR Dump Before ArithToLLVMConversionPass (convert-arith-to-llvm) //----- //
module attributes {gpu.container_module} {
  gpu.module @kernels {
    gpu.func @vector_constant_mask(%arg0: memref<4x3xi1>) kernel {
      %c0 = arith.constant 0 : index
      %0 = vector.constant_mask [3, 2] : vector<4x3xi1>
      vector.store %0, %arg0[%c0, %c0] : memref<4x3xi1>, vector<4x3xi1>
      gpu.return
    }
  }
  func.func @main() {
    %c1 = arith.constant 1 : index
    %alloc = memref.alloc() : memref<4x3xi1>
    %cast = memref.cast %alloc : memref<4x3xi1> to memref<*xi1>
    gpu.host_register %cast : memref<*xi1>
    gpu.launch_func  @kernels::@vector_constant_mask blocks in (%c1, %c1, %c1) threads in (%c1, %c1, %c1)  args(%alloc : memref<4x3xi1>)
    call @printMemrefI32(%cast) : (memref<*xi1>) -> ()
    return
  }
  func.func private @printMemrefI32(memref<*xi1>)
}


// -----// IR Dump Before ConvertVectorToLLVMPass (convert-vector-to-llvm) //----- //
module attributes {gpu.container_module} {
  gpu.module @kernels {
    gpu.func @vector_constant_mask(%arg0: memref<4x3xi1>) kernel {
      %0 = llvm.mlir.constant(0 : index) : i64
      %1 = builtin.unrealized_conversion_cast %0 : i64 to index
      %2 = vector.constant_mask [3, 2] : vector<4x3xi1>
      vector.store %2, %arg0[%1, %1] : memref<4x3xi1>, vector<4x3xi1>
      gpu.return
    }
  }
  func.func @main() {
    %0 = llvm.mlir.constant(1 : index) : i64
    %1 = builtin.unrealized_conversion_cast %0 : i64 to index
    %alloc = memref.alloc() : memref<4x3xi1>
    %cast = memref.cast %alloc : memref<4x3xi1> to memref<*xi1>
    gpu.host_register %cast : memref<*xi1>
    gpu.launch_func  @kernels::@vector_constant_mask blocks in (%1, %1, %1) threads in (%1, %1, %1)  args(%alloc : memref<4x3xi1>)
    call @printMemrefI32(%cast) : (memref<*xi1>) -> ()
    return
  }
  func.func private @printMemrefI32(memref<*xi1>)
}


// -----// IR Dump Before ConvertFuncToLLVMPass (convert-func-to-llvm) //----- //
module attributes {gpu.container_module} {
  gpu.module @kernels {
    gpu.func @vector_constant_mask(%arg0: memref<4x3xi1>) kernel {
      %cst = arith.constant dense<[true, true, false]> : vector<3xi1>
      %cst_0 = arith.constant dense<false> : vector<4x3xi1>
      %0 = builtin.unrealized_conversion_cast %cst_0 : vector<4x3xi1> to !llvm.array<4 x vector<3xi1>>
      %1 = llvm.mlir.constant(0 : index) : i64
      %2 = builtin.unrealized_conversion_cast %1 : i64 to index
      %3 = llvm.insertvalue %cst, %0[0] : !llvm.array<4 x vector<3xi1>> 
      %4 = llvm.insertvalue %cst, %3[1] : !llvm.array<4 x vector<3xi1>> 
      %5 = llvm.insertvalue %cst, %4[2] : !llvm.array<4 x vector<3xi1>> 
      %6 = builtin.unrealized_conversion_cast %5 : !llvm.array<4 x vector<3xi1>> to vector<4x3xi1>
      vector.store %6, %arg0[%2, %2] : memref<4x3xi1>, vector<4x3xi1>
      gpu.return
    }
  }
  func.func @main() {
    %0 = llvm.mlir.constant(1 : index) : i64
    %1 = builtin.unrealized_conversion_cast %0 : i64 to index
    %alloc = memref.alloc() : memref<4x3xi1>
    %cast = memref.cast %alloc : memref<4x3xi1> to memref<*xi1>
    gpu.host_register %cast : memref<*xi1>
    gpu.launch_func  @kernels::@vector_constant_mask blocks in (%1, %1, %1) threads in (%1, %1, %1)  args(%alloc : memref<4x3xi1>)
    call @printMemrefI32(%cast) : (memref<*xi1>) -> ()
    return
  }
  func.func private @printMemrefI32(memref<*xi1>)
}


// -----// IR Dump Before GpuKernelOutlining (gpu-kernel-outlining) //----- //
module attributes {gpu.container_module} {
  gpu.module @kernels {
    gpu.func @vector_constant_mask(%arg0: memref<4x3xi1>) kernel {
      %0 = llvm.mlir.constant(dense<[true, true, false]> : vector<3xi1>) : vector<3xi1>
      %1 = llvm.mlir.constant(dense<false> : vector<4x3xi1>) : !llvm.array<4 x vector<3xi1>>
      %2 = builtin.unrealized_conversion_cast %1 : !llvm.array<4 x vector<3xi1>> to vector<4x3xi1>
      %3 = builtin.unrealized_conversion_cast %2 : vector<4x3xi1> to !llvm.array<4 x vector<3xi1>>
      %4 = llvm.mlir.constant(0 : index) : i64
      %5 = builtin.unrealized_conversion_cast %4 : i64 to index
      %6 = llvm.insertvalue %0, %3[0] : !llvm.array<4 x vector<3xi1>> 
      %7 = llvm.insertvalue %0, %6[1] : !llvm.array<4 x vector<3xi1>> 
      %8 = llvm.insertvalue %0, %7[2] : !llvm.array<4 x vector<3xi1>> 
      %9 = builtin.unrealized_conversion_cast %8 : !llvm.array<4 x vector<3xi1>> to vector<4x3xi1>
      vector.store %9, %arg0[%5, %5] : memref<4x3xi1>, vector<4x3xi1>
      gpu.return
    }
  }
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : index) : i64
    %1 = builtin.unrealized_conversion_cast %0 : i64 to index
    %alloc = memref.alloc() : memref<4x3xi1>
    %cast = memref.cast %alloc : memref<4x3xi1> to memref<*xi1>
    %2 = builtin.unrealized_conversion_cast %cast : memref<*xi1> to !llvm.struct<(i64, ptr)>
    gpu.host_register %cast : memref<*xi1>
    gpu.launch_func  @kernels::@vector_constant_mask blocks in (%1, %1, %1) threads in (%1, %1, %1)  args(%alloc : memref<4x3xi1>)
    %3 = llvm.extractvalue %2[0] : !llvm.struct<(i64, ptr)> 
    %4 = llvm.extractvalue %2[1] : !llvm.struct<(i64, ptr)> 
    llvm.call @printMemrefI32(%3, %4) : (i64, !llvm.ptr) -> ()
    llvm.return
  }
  llvm.func @printMemrefI32(i64, !llvm.ptr) attributes {sym_visibility = "private"}
}


// -----// IR Dump Before GpuNVVMAttachTarget (nvvm-attach-target) //----- //
module attributes {gpu.container_module} {
  gpu.module @kernels {
    gpu.func @vector_constant_mask(%arg0: memref<4x3xi1>) kernel {
      %0 = llvm.mlir.constant(dense<[true, true, false]> : vector<3xi1>) : vector<3xi1>
      %1 = llvm.mlir.constant(dense<false> : vector<4x3xi1>) : !llvm.array<4 x vector<3xi1>>
      %2 = builtin.unrealized_conversion_cast %1 : !llvm.array<4 x vector<3xi1>> to vector<4x3xi1>
      %3 = builtin.unrealized_conversion_cast %2 : vector<4x3xi1> to !llvm.array<4 x vector<3xi1>>
      %4 = llvm.mlir.constant(0 : index) : i64
      %5 = builtin.unrealized_conversion_cast %4 : i64 to index
      %6 = llvm.insertvalue %0, %3[0] : !llvm.array<4 x vector<3xi1>> 
      %7 = llvm.insertvalue %0, %6[1] : !llvm.array<4 x vector<3xi1>> 
      %8 = llvm.insertvalue %0, %7[2] : !llvm.array<4 x vector<3xi1>> 
      %9 = builtin.unrealized_conversion_cast %8 : !llvm.array<4 x vector<3xi1>> to vector<4x3xi1>
      vector.store %9, %arg0[%5, %5] : memref<4x3xi1>, vector<4x3xi1>
      gpu.return
    }
  }
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : index) : i64
    %1 = builtin.unrealized_conversion_cast %0 : i64 to index
    %alloc = memref.alloc() : memref<4x3xi1>
    %cast = memref.cast %alloc : memref<4x3xi1> to memref<*xi1>
    %2 = builtin.unrealized_conversion_cast %cast : memref<*xi1> to !llvm.struct<(i64, ptr)>
    gpu.host_register %cast : memref<*xi1>
    gpu.launch_func  @kernels::@vector_constant_mask blocks in (%1, %1, %1) threads in (%1, %1, %1)  args(%alloc : memref<4x3xi1>)
    %3 = llvm.extractvalue %2[0] : !llvm.struct<(i64, ptr)> 
    %4 = llvm.extractvalue %2[1] : !llvm.struct<(i64, ptr)> 
    llvm.call @printMemrefI32(%3, %4) : (i64, !llvm.ptr) -> ()
    llvm.return
  }
  llvm.func @printMemrefI32(i64, !llvm.ptr) attributes {sym_visibility = "private"}
}


// -----// IR Dump Before StripDebugInfo (strip-debuginfo) //----- //
module attributes {gpu.container_module} {
  gpu.module @kernels [#nvvm.target<O = 3, chip = "sm_89">]  {
    gpu.func @vector_constant_mask(%arg0: memref<4x3xi1>) kernel {
      %0 = llvm.mlir.constant(dense<[true, true, false]> : vector<3xi1>) : vector<3xi1>
      %1 = llvm.mlir.constant(dense<false> : vector<4x3xi1>) : !llvm.array<4 x vector<3xi1>>
      %2 = builtin.unrealized_conversion_cast %1 : !llvm.array<4 x vector<3xi1>> to vector<4x3xi1>
      %3 = builtin.unrealized_conversion_cast %2 : vector<4x3xi1> to !llvm.array<4 x vector<3xi1>>
      %4 = llvm.mlir.constant(0 : index) : i64
      %5 = builtin.unrealized_conversion_cast %4 : i64 to index
      %6 = llvm.insertvalue %0, %3[0] : !llvm.array<4 x vector<3xi1>> 
      %7 = llvm.insertvalue %0, %6[1] : !llvm.array<4 x vector<3xi1>> 
      %8 = llvm.insertvalue %0, %7[2] : !llvm.array<4 x vector<3xi1>> 
      %9 = builtin.unrealized_conversion_cast %8 : !llvm.array<4 x vector<3xi1>> to vector<4x3xi1>
      vector.store %9, %arg0[%5, %5] : memref<4x3xi1>, vector<4x3xi1>
      gpu.return
    }
  }
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : index) : i64
    %1 = builtin.unrealized_conversion_cast %0 : i64 to index
    %alloc = memref.alloc() : memref<4x3xi1>
    %cast = memref.cast %alloc : memref<4x3xi1> to memref<*xi1>
    %2 = builtin.unrealized_conversion_cast %cast : memref<*xi1> to !llvm.struct<(i64, ptr)>
    gpu.host_register %cast : memref<*xi1>
    gpu.launch_func  @kernels::@vector_constant_mask blocks in (%1, %1, %1) threads in (%1, %1, %1)  args(%alloc : memref<4x3xi1>)
    %3 = llvm.extractvalue %2[0] : !llvm.struct<(i64, ptr)> 
    %4 = llvm.extractvalue %2[1] : !llvm.struct<(i64, ptr)> 
    llvm.call @printMemrefI32(%3, %4) : (i64, !llvm.ptr) -> ()
    llvm.return
  }
  llvm.func @printMemrefI32(i64, !llvm.ptr) attributes {sym_visibility = "private"}
}


// -----// IR Dump Before ConvertGpuOpsToNVVMOps (convert-gpu-to-nvvm) //----- //
gpu.module @kernels [#nvvm.target<O = 3, chip = "sm_89">]  {
  gpu.func @vector_constant_mask(%arg0: memref<4x3xi1>) kernel {
    %0 = llvm.mlir.constant(dense<[true, true, false]> : vector<3xi1>) : vector<3xi1>
    %1 = llvm.mlir.constant(dense<false> : vector<4x3xi1>) : !llvm.array<4 x vector<3xi1>>
    %2 = builtin.unrealized_conversion_cast %1 : !llvm.array<4 x vector<3xi1>> to vector<4x3xi1>
    %3 = builtin.unrealized_conversion_cast %2 : vector<4x3xi1> to !llvm.array<4 x vector<3xi1>>
    %4 = llvm.mlir.constant(0 : index) : i64
    %5 = builtin.unrealized_conversion_cast %4 : i64 to index
    %6 = llvm.insertvalue %0, %3[0] : !llvm.array<4 x vector<3xi1>> 
    %7 = llvm.insertvalue %0, %6[1] : !llvm.array<4 x vector<3xi1>> 
    %8 = llvm.insertvalue %0, %7[2] : !llvm.array<4 x vector<3xi1>> 
    %9 = builtin.unrealized_conversion_cast %8 : !llvm.array<4 x vector<3xi1>> to vector<4x3xi1>
    vector.store %9, %arg0[%5, %5] : memref<4x3xi1>, vector<4x3xi1>
    gpu.return
  }
}

// -----// IR Dump Before GpuToLLVMConversionPass (gpu-to-llvm) //----- //
module attributes {gpu.container_module} {
  gpu.module @kernels [#nvvm.target<O = 3, chip = "sm_89">]  {
    llvm.func @vector_constant_mask(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i64) attributes {gpu.kernel, nvvm.kernel} {
      %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
      %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
      %2 = llvm.insertvalue %arg1, %1[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
      %3 = llvm.insertvalue %arg2, %2[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
      %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
      %5 = llvm.insertvalue %arg5, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
      %6 = llvm.insertvalue %arg4, %5[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
      %7 = llvm.insertvalue %arg6, %6[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
      %8 = builtin.unrealized_conversion_cast %7 : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> to memref<4x3xi1>
      %9 = llvm.mlir.constant(0 : index) : i64
      %10 = llvm.mlir.constant(dense<[true, true, false]> : vector<3xi1>) : vector<3xi1>
      %11 = llvm.mlir.constant(dense<false> : vector<4x3xi1>) : !llvm.array<4 x vector<3xi1>>
      %12 = builtin.unrealized_conversion_cast %9 : i64 to index
      %13 = llvm.insertvalue %10, %11[0] : !llvm.array<4 x vector<3xi1>> 
      %14 = llvm.insertvalue %10, %13[1] : !llvm.array<4 x vector<3xi1>> 
      %15 = llvm.insertvalue %10, %14[2] : !llvm.array<4 x vector<3xi1>> 
      %16 = builtin.unrealized_conversion_cast %15 : !llvm.array<4 x vector<3xi1>> to vector<4x3xi1>
      vector.store %16, %8[%12, %12] : memref<4x3xi1>, vector<4x3xi1>
      llvm.return
    }
  }
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : index) : i64
    %1 = builtin.unrealized_conversion_cast %0 : i64 to index
    %alloc = memref.alloc() : memref<4x3xi1>
    %cast = memref.cast %alloc : memref<4x3xi1> to memref<*xi1>
    %2 = builtin.unrealized_conversion_cast %cast : memref<*xi1> to !llvm.struct<(i64, ptr)>
    gpu.host_register %cast : memref<*xi1>
    gpu.launch_func  @kernels::@vector_constant_mask blocks in (%1, %1, %1) threads in (%1, %1, %1)  args(%alloc : memref<4x3xi1>)
    %3 = llvm.extractvalue %2[0] : !llvm.struct<(i64, ptr)> 
    %4 = llvm.extractvalue %2[1] : !llvm.struct<(i64, ptr)> 
    llvm.call @printMemrefI32(%3, %4) : (i64, !llvm.ptr) -> ()
    llvm.return
  }
  llvm.func @printMemrefI32(i64, !llvm.ptr) attributes {sym_visibility = "private"}
}


// -----// IR Dump Before ReconcileUnrealizedCasts (reconcile-unrealized-casts) //----- //
module attributes {gpu.container_module} {
  llvm.func @malloc(i64) -> !llvm.ptr
  gpu.module @kernels [#nvvm.target<O = 3, chip = "sm_89">]  {
    llvm.func @vector_constant_mask(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i64) attributes {gpu.kernel, nvvm.kernel} {
      %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
      %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
      %2 = llvm.insertvalue %arg1, %1[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
      %3 = llvm.insertvalue %arg2, %2[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
      %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
      %5 = llvm.insertvalue %arg5, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
      %6 = llvm.insertvalue %arg4, %5[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
      %7 = llvm.insertvalue %arg6, %6[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
      %8 = builtin.unrealized_conversion_cast %7 : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> to memref<4x3xi1>
      %9 = llvm.mlir.constant(0 : index) : i64
      %10 = llvm.mlir.constant(dense<[true, true, false]> : vector<3xi1>) : vector<3xi1>
      %11 = llvm.mlir.constant(dense<false> : vector<4x3xi1>) : !llvm.array<4 x vector<3xi1>>
      %12 = builtin.unrealized_conversion_cast %9 : i64 to index
      %13 = llvm.insertvalue %10, %11[0] : !llvm.array<4 x vector<3xi1>> 
      %14 = llvm.insertvalue %10, %13[1] : !llvm.array<4 x vector<3xi1>> 
      %15 = llvm.insertvalue %10, %14[2] : !llvm.array<4 x vector<3xi1>> 
      %16 = builtin.unrealized_conversion_cast %15 : !llvm.array<4 x vector<3xi1>> to vector<4x3xi1>
      vector.store %16, %8[%12, %12] : memref<4x3xi1>, vector<4x3xi1>
      llvm.return
    }
  }
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : index) : i64
    %1 = builtin.unrealized_conversion_cast %0 : i64 to index
    %2 = llvm.mlir.constant(4 : index) : i64
    %3 = llvm.mlir.constant(3 : index) : i64
    %4 = llvm.mlir.constant(1 : index) : i64
    %5 = llvm.mlir.constant(12 : index) : i64
    %6 = llvm.mlir.zero : !llvm.ptr
    %7 = llvm.getelementptr %6[%5] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    %8 = llvm.ptrtoint %7 : !llvm.ptr to i64
    %9 = llvm.call @malloc(%8) : (i64) -> !llvm.ptr
    %10 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %11 = llvm.insertvalue %9, %10[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %12 = llvm.insertvalue %9, %11[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %13 = llvm.mlir.constant(0 : index) : i64
    %14 = llvm.insertvalue %13, %12[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %15 = llvm.insertvalue %2, %14[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %16 = llvm.insertvalue %3, %15[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %17 = llvm.insertvalue %3, %16[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %18 = llvm.insertvalue %4, %17[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %19 = llvm.mlir.constant(1 : index) : i64
    %20 = llvm.alloca %19 x !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> : (i64) -> !llvm.ptr
    llvm.store %18, %20 : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>, !llvm.ptr
    %21 = llvm.mlir.constant(2 : index) : i64
    %22 = llvm.mlir.undef : !llvm.struct<(i64, ptr)>
    %23 = llvm.insertvalue %21, %22[0] : !llvm.struct<(i64, ptr)> 
    %24 = llvm.insertvalue %20, %23[1] : !llvm.struct<(i64, ptr)> 
    %25 = builtin.unrealized_conversion_cast %24 : !llvm.struct<(i64, ptr)> to memref<*xi1>
    %26 = builtin.unrealized_conversion_cast %25 : memref<*xi1> to !llvm.struct<(i64, ptr)>
    %27 = llvm.mlir.zero : !llvm.ptr
    %28 = llvm.getelementptr %27[1] : (!llvm.ptr) -> !llvm.ptr, i1
    %29 = llvm.ptrtoint %28 : !llvm.ptr to i64
    %30 = llvm.extractvalue %24[0] : !llvm.struct<(i64, ptr)> 
    %31 = llvm.extractvalue %24[1] : !llvm.struct<(i64, ptr)> 
    llvm.call @mgpuMemHostRegisterMemRef(%30, %31, %29) : (i64, !llvm.ptr, i64) -> ()
    %32 = llvm.extractvalue %18[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %33 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %34 = llvm.extractvalue %18[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %35 = llvm.extractvalue %18[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %36 = llvm.extractvalue %18[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %37 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %38 = llvm.extractvalue %18[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    gpu.launch_func  @kernels::@vector_constant_mask blocks in (%0, %0, %0) threads in (%0, %0, %0) : i64 args(%32 : !llvm.ptr, %33 : !llvm.ptr, %34 : i64, %35 : i64, %36 : i64, %37 : i64, %38 : i64)
    %39 = llvm.extractvalue %26[0] : !llvm.struct<(i64, ptr)> 
    %40 = llvm.extractvalue %26[1] : !llvm.struct<(i64, ptr)> 
    llvm.call @printMemrefI32(%39, %40) : (i64, !llvm.ptr) -> ()
    llvm.return
  }
  llvm.func @printMemrefI32(i64, !llvm.ptr) attributes {sym_visibility = "private"}
  llvm.func @mgpuMemHostRegisterMemRef(i64, !llvm.ptr, i64)
}


<unknown>:0: error: failed to legalize operation 'builtin.unrealized_conversion_cast' that was explicitly marked illegal
<unknown>:0: note: see current operation: %8 = "builtin.unrealized_conversion_cast"(%7) : (!llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>) -> memref<4x3xi1>
make: *** [makefile:213: vector-constant-mask-lower] Error 1
