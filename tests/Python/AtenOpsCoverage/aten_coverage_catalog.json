[
  {
    "op": "abs",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::abs(Tensor self) -> Tensor"
  },
  {
    "op": "abs",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::abs.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "abs_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::abs_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "absolute",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::absolute(Tensor self) -> Tensor"
  },
  {
    "op": "absolute",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::absolute.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "absolute_",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::absolute_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "acos",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::acos(Tensor self) -> Tensor"
  },
  {
    "op": "acos",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::acos.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "acos",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::acos.int(int a) -> float"
  },
  {
    "op": "acos",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::acos.float(float a) -> float"
  },
  {
    "op": "acos",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::acos.complex(complex a) -> complex"
  },
  {
    "op": "acos",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::acos.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "acos_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::acos_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "acosh",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::acosh(Tensor self) -> Tensor"
  },
  {
    "op": "acosh",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::acosh.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "acosh",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::acosh.int(int a) -> float"
  },
  {
    "op": "acosh",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::acosh.float(float a) -> float"
  },
  {
    "op": "acosh",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::acosh.complex(complex a) -> complex"
  },
  {
    "op": "acosh",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::acosh.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "acosh_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::acosh_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "adaptive_max_pool2d",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size,view_like",
    "schema": "aten::adaptive_max_pool2d(Tensor self, int[2] output_size) -> (Tensor, Tensor)"
  },
  {
    "op": "adaptive_max_pool2d",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size,view_like",
    "schema": "aten::adaptive_max_pool2d.out(Tensor self, int[2] output_size, *, Tensor(a!) out, Tensor(b!) indices) -> (Tensor(a!), Tensor(b!))"
  },
  {
    "op": "adaptive_max_pool2d_backward",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::adaptive_max_pool2d_backward(Tensor grad_output, Tensor self, Tensor indices) -> Tensor"
  },
  {
    "op": "adaptive_max_pool2d_backward",
    "overload": "grad_input",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::adaptive_max_pool2d_backward.grad_input(Tensor grad_output, Tensor self, Tensor indices, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "adaptive_max_pool3d",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size,view_like",
    "schema": "aten::adaptive_max_pool3d(Tensor self, int[3] output_size) -> (Tensor, Tensor)"
  },
  {
    "op": "adaptive_max_pool3d",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size,view_like",
    "schema": "aten::adaptive_max_pool3d.out(Tensor self, int[3] output_size, *, Tensor(a!) out, Tensor(b!) indices) -> (Tensor(a!), Tensor(b!))"
  },
  {
    "op": "adaptive_max_pool3d_backward",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::adaptive_max_pool3d_backward(Tensor grad_output, Tensor self, Tensor indices) -> Tensor"
  },
  {
    "op": "adaptive_max_pool3d_backward",
    "overload": "grad_input",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::adaptive_max_pool3d_backward.grad_input(Tensor grad_output, Tensor self, Tensor indices, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "add",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::add.Tensor(Tensor self, Tensor other, *, Scalar alpha=1) -> Tensor"
  },
  {
    "op": "add",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other",
    "schema": "aten::add.Scalar(Tensor self, Scalar other, Scalar alpha=1) -> Tensor"
  },
  {
    "op": "add",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::add.out(Tensor self, Tensor other, *, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "add",
    "overload": "Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::add.Scalar_out(Tensor self, Scalar other, Scalar alpha=1, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "add",
    "overload": "t",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::add.t(t[] a, t[] b) -> t[]"
  },
  {
    "op": "add",
    "overload": "str",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::add.str(str a, str b) -> str"
  },
  {
    "op": "add",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::add.int(int a, int b) -> int"
  },
  {
    "op": "add",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b",
    "schema": "aten::add.complex(complex a, complex b) -> complex"
  },
  {
    "op": "add",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::add.float(float a, float b) -> float"
  },
  {
    "op": "add",
    "overload": "int_complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:b,view_like",
    "schema": "aten::add.int_complex(int a, complex b) -> complex"
  },
  {
    "op": "add",
    "overload": "complex_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a,view_like",
    "schema": "aten::add.complex_int(complex a, int b) -> complex"
  },
  {
    "op": "add",
    "overload": "float_complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:b,view_like",
    "schema": "aten::add.float_complex(float a, complex b) -> complex"
  },
  {
    "op": "add",
    "overload": "complex_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a,view_like",
    "schema": "aten::add.complex_float(complex a, float b) -> complex"
  },
  {
    "op": "add",
    "overload": "int_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::add.int_float(int a, float b) -> float"
  },
  {
    "op": "add",
    "overload": "float_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::add.float_int(float a, int b) -> float"
  },
  {
    "op": "add",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::add(Scalar a, Scalar b) -> Scalar"
  },
  {
    "op": "add_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::add_.Tensor(Tensor(a!) self, Tensor other, *, Scalar alpha=1) -> Tensor(a!)"
  },
  {
    "op": "add_",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other",
    "schema": "aten::add_.Scalar(Tensor(a!) self, Scalar other, Scalar alpha=1) -> Tensor(a!)"
  },
  {
    "op": "add_",
    "overload": "t",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "inplace,input_missing:self|b,view_like",
    "schema": "aten::add_.t(t[](a!) self, t[] b) -> t[]"
  },
  {
    "op": "addbmm",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::addbmm(Tensor self, Tensor batch1, Tensor batch2, *, Scalar beta=1, Scalar alpha=1) -> Tensor"
  },
  {
    "op": "addbmm",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::addbmm.out(Tensor self, Tensor batch1, Tensor batch2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "addbmm_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::addbmm_(Tensor(a!) self, Tensor batch1, Tensor batch2, *, Scalar beta=1, Scalar alpha=1) -> Tensor(a!)"
  },
  {
    "op": "addcdiv",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::addcdiv(Tensor self, Tensor tensor1, Tensor tensor2, *, Scalar value=1) -> Tensor"
  },
  {
    "op": "addcdiv",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::addcdiv.out(Tensor self, Tensor tensor1, Tensor tensor2, *, Scalar value=1, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "addcdiv_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::addcdiv_(Tensor(a!) self, Tensor tensor1, Tensor tensor2, *, Scalar value=1) -> Tensor(a!)"
  },
  {
    "op": "addcmul",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::addcmul(Tensor self, Tensor tensor1, Tensor tensor2, *, Scalar value=1) -> Tensor"
  },
  {
    "op": "addcmul",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::addcmul.out(Tensor self, Tensor tensor1, Tensor tensor2, *, Scalar value=1, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "addcmul_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::addcmul_(Tensor(a!) self, Tensor tensor1, Tensor tensor2, *, Scalar value=1) -> Tensor(a!)"
  },
  {
    "op": "addmm",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::addmm(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -> Tensor"
  },
  {
    "op": "addmm",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::addmm.out(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "addmm",
    "overload": "dtype_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_ready,view_like",
    "schema": "aten::addmm.dtype_out(Tensor self, Tensor mat1, Tensor mat2, ScalarType out_dtype, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "addmm",
    "overload": "dtype",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_ready,view_like",
    "schema": "aten::addmm.dtype(Tensor self, Tensor mat1, Tensor mat2, ScalarType out_dtype, *, Scalar beta=1, Scalar alpha=1) -> Tensor"
  },
  {
    "op": "addmm_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::addmm_(Tensor(a!) self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -> Tensor(a!)"
  },
  {
    "op": "addmv",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::addmv(Tensor self, Tensor mat, Tensor vec, *, Scalar beta=1, Scalar alpha=1) -> Tensor"
  },
  {
    "op": "addmv",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::addmv.out(Tensor self, Tensor mat, Tensor vec, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "addmv_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::addmv_(Tensor(a!) self, Tensor mat, Tensor vec, *, Scalar beta=1, Scalar alpha=1) -> Tensor(a!)"
  },
  {
    "op": "addr",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::addr(Tensor self, Tensor vec1, Tensor vec2, *, Scalar beta=1, Scalar alpha=1) -> Tensor"
  },
  {
    "op": "addr",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::addr.out(Tensor self, Tensor vec1, Tensor vec2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "affine_grid_generator",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size,view_like",
    "schema": "aten::affine_grid_generator(Tensor theta, SymInt[] size, bool align_corners) -> Tensor"
  },
  {
    "op": "affine_grid_generator",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size,view_like",
    "schema": "aten::affine_grid_generator.out(Tensor theta, SymInt[] size, bool align_corners, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "alias",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::alias(Tensor(a) self) -> Tensor(a)"
  },
  {
    "op": "alias_copy",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::alias_copy(Tensor self) -> Tensor"
  },
  {
    "op": "alias_copy",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::alias_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "all",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::all(Tensor self) -> Tensor"
  },
  {
    "op": "all",
    "overload": "dim",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready",
    "schema": "aten::all.dim(Tensor self, int dim, bool keepdim=False) -> Tensor"
  },
  {
    "op": "all",
    "overload": "dims",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::all.dims(Tensor self, int[]? dim=None, bool keepdim=False) -> Tensor"
  },
  {
    "op": "all",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::all.out(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "all",
    "overload": "dims_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::all.dims_out(Tensor self, int[]? dim=None, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "all",
    "overload": "all_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::all.all_out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "all",
    "overload": "dimname",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::all.dimname(Tensor self, str dim, bool keepdim=False) -> Tensor"
  },
  {
    "op": "all",
    "overload": "dimname_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::all.dimname_out(Tensor self, str dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "all",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self,view_like",
    "schema": "aten::all.int(int[] self) -> bool"
  },
  {
    "op": "all",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self,view_like",
    "schema": "aten::all.float(float[] self) -> bool"
  },
  {
    "op": "all",
    "overload": "bool",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self",
    "schema": "aten::all.bool(bool[] self) -> bool"
  },
  {
    "op": "alpha_dropout",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,random,view_like",
    "schema": "aten::alpha_dropout(Tensor input, float p, bool train) -> Tensor"
  },
  {
    "op": "amax",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::amax(Tensor self, int[1] dim=[], bool keepdim=False) -> Tensor"
  },
  {
    "op": "amax",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::amax.out(Tensor self, int[1] dim=[], bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "amin",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::amin(Tensor self, int[1] dim=[], bool keepdim=False) -> Tensor"
  },
  {
    "op": "amin",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::amin.out(Tensor self, int[1] dim=[], bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "aminmax",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::aminmax(Tensor self, *, int? dim=None, bool keepdim=False) -> (Tensor min, Tensor max)"
  },
  {
    "op": "aminmax",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::aminmax.out(Tensor self, *, int? dim=None, bool keepdim=False, Tensor(a!) min, Tensor(b!) max) -> (Tensor(a!) min, Tensor(b!) max)"
  },
  {
    "op": "angle",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::angle(Tensor self) -> Tensor"
  },
  {
    "op": "angle",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::angle.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "angle",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::angle.int(int a) -> float"
  },
  {
    "op": "angle",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::angle.float(float a) -> float"
  },
  {
    "op": "angle",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::angle.complex(complex a) -> float"
  },
  {
    "op": "angle",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::angle.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "any",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::any(Tensor self) -> Tensor"
  },
  {
    "op": "any",
    "overload": "dim",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready",
    "schema": "aten::any.dim(Tensor self, int dim, bool keepdim=False) -> Tensor"
  },
  {
    "op": "any",
    "overload": "dims",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::any.dims(Tensor self, int[]? dim=None, bool keepdim=False) -> Tensor"
  },
  {
    "op": "any",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::any.out(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "any",
    "overload": "dims_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::any.dims_out(Tensor self, int[]? dim=None, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "any",
    "overload": "all_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::any.all_out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "any",
    "overload": "dimname",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::any.dimname(Tensor self, str dim, bool keepdim=False) -> Tensor"
  },
  {
    "op": "any",
    "overload": "dimname_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::any.dimname_out(Tensor self, str dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "any",
    "overload": "str",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self,view_like",
    "schema": "aten::any.str(str[] self) -> bool"
  },
  {
    "op": "any",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self,view_like",
    "schema": "aten::any.int(int[] self) -> bool"
  },
  {
    "op": "any",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self,view_like",
    "schema": "aten::any.float(float[] self) -> bool"
  },
  {
    "op": "any",
    "overload": "bool",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self",
    "schema": "aten::any.bool(bool[] self) -> bool"
  },
  {
    "op": "arange",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:end|dtype|layout|pin_memory,view_like",
    "schema": "aten::arange(Scalar end, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "arange",
    "overload": "start",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:start|end|dtype|layout|pin_memory,view_like",
    "schema": "aten::arange.start(Scalar start, Scalar end, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "arange",
    "overload": "start_step",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:start|end|dtype|layout|pin_memory,view_like",
    "schema": "aten::arange.start_step(Scalar start, Scalar end, Scalar step=1, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "arange",
    "overload": "start_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:start|end,view_like",
    "schema": "aten::arange.start_out(Scalar start, Scalar end, Scalar step=1, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "arange",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:end,view_like",
    "schema": "aten::arange.out(Scalar end, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "arccos",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::arccos(Tensor self) -> Tensor"
  },
  {
    "op": "arccos",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::arccos.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "arccos_",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::arccos_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "arccosh",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::arccosh(Tensor self) -> Tensor"
  },
  {
    "op": "arccosh",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::arccosh.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "arccosh_",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::arccosh_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "arcsin",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::arcsin(Tensor self) -> Tensor"
  },
  {
    "op": "arcsin",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::arcsin.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "arcsin_",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::arcsin_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "arcsinh",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::arcsinh(Tensor self) -> Tensor"
  },
  {
    "op": "arcsinh",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::arcsinh.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "arcsinh_",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::arcsinh_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "arctan",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::arctan(Tensor self) -> Tensor"
  },
  {
    "op": "arctan",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::arctan.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "arctan2",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::arctan2(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "arctan2",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::arctan2.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "arctan2_",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::arctan2_(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "arctan_",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::arctan_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "arctanh",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::arctanh(Tensor self) -> Tensor"
  },
  {
    "op": "arctanh",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::arctanh.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "arctanh_",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::arctanh_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "argmax",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::argmax(Tensor self, int? dim=None, bool keepdim=False) -> Tensor"
  },
  {
    "op": "argmax",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::argmax.out(Tensor self, int? dim=None, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "argmin",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::argmin(Tensor self, int? dim=None, bool keepdim=False) -> Tensor"
  },
  {
    "op": "argmin",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::argmin.out(Tensor self, int? dim=None, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "as_strided",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|stride|storage_offset,view_like",
    "schema": "aten::as_strided(Tensor(a) self, SymInt[] size, SymInt[] stride, SymInt? storage_offset=None) -> Tensor(a)"
  },
  {
    "op": "as_strided_",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:size|stride|storage_offset,view_like",
    "schema": "aten::as_strided_(Tensor(a!) self, SymInt[] size, SymInt[] stride, SymInt? storage_offset=None) -> Tensor(a!)"
  },
  {
    "op": "as_strided_copy",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|stride|storage_offset,view_like",
    "schema": "aten::as_strided_copy(Tensor self, SymInt[] size, SymInt[] stride, SymInt? storage_offset=None) -> Tensor"
  },
  {
    "op": "as_strided_copy",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|stride|storage_offset,view_like",
    "schema": "aten::as_strided_copy.out(Tensor self, SymInt[] size, SymInt[] stride, SymInt? storage_offset=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "as_strided_scatter",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|stride|storage_offset,view_like",
    "schema": "aten::as_strided_scatter(Tensor self, Tensor src, SymInt[] size, SymInt[] stride, SymInt? storage_offset=None) -> Tensor"
  },
  {
    "op": "as_strided_scatter",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|stride|storage_offset,view_like",
    "schema": "aten::as_strided_scatter.out(Tensor self, Tensor src, SymInt[] size, SymInt[] stride, SymInt? storage_offset=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "asin",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::asin(Tensor self) -> Tensor"
  },
  {
    "op": "asin",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::asin.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "asin",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::asin.int(int a) -> float"
  },
  {
    "op": "asin",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::asin.float(float a) -> float"
  },
  {
    "op": "asin",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::asin.complex(complex a) -> complex"
  },
  {
    "op": "asin",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::asin.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "asin_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::asin_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "asinh",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::asinh(Tensor self) -> Tensor"
  },
  {
    "op": "asinh",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::asinh.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "asinh",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::asinh.int(int a) -> float"
  },
  {
    "op": "asinh",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::asinh.float(float a) -> float"
  },
  {
    "op": "asinh",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::asinh.complex(complex a) -> complex"
  },
  {
    "op": "asinh",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::asinh.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "asinh_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::asinh_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "atan",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::atan(Tensor self) -> Tensor"
  },
  {
    "op": "atan",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::atan.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "atan",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::atan.int(int a) -> float"
  },
  {
    "op": "atan",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::atan.float(float a) -> float"
  },
  {
    "op": "atan",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a,view_like",
    "schema": "aten::atan.complex(complex a) -> complex"
  },
  {
    "op": "atan",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a,view_like",
    "schema": "aten::atan.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "atan2",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::atan2(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "atan2",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::atan2.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "atan2",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::atan2.int(int a, int b) -> float"
  },
  {
    "op": "atan2",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::atan2.float(float a, float b) -> float"
  },
  {
    "op": "atan2",
    "overload": "int_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::atan2.int_float(int a, float b) -> float"
  },
  {
    "op": "atan2",
    "overload": "float_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::atan2.float_int(float a, int b) -> float"
  },
  {
    "op": "atan2",
    "overload": "Scalar_Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::atan2.Scalar_Scalar(Scalar a, Scalar b) -> float"
  },
  {
    "op": "atan2_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::atan2_(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "atan_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::atan_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "atanh",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::atanh(Tensor self) -> Tensor"
  },
  {
    "op": "atanh",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::atanh.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "atanh",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::atanh.int(int a) -> float"
  },
  {
    "op": "atanh",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::atanh.float(float a) -> float"
  },
  {
    "op": "atanh",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a,view_like",
    "schema": "aten::atanh.complex(complex a) -> complex"
  },
  {
    "op": "atanh",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a,view_like",
    "schema": "aten::atanh.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "atanh_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::atanh_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "avg_pool2d",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:kernel_size|divisor_override,view_like",
    "schema": "aten::avg_pool2d(Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, bool ceil_mode=False, bool count_include_pad=True, int? divisor_override=None) -> Tensor"
  },
  {
    "op": "avg_pool2d",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:kernel_size|divisor_override,view_like",
    "schema": "aten::avg_pool2d.out(Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, bool ceil_mode=False, bool count_include_pad=True, int? divisor_override=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "avg_pool2d_backward",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:kernel_size|stride|padding|divisor_override,view_like",
    "schema": "aten::avg_pool2d_backward(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride, int[2] padding, bool ceil_mode, bool count_include_pad, int? divisor_override) -> Tensor"
  },
  {
    "op": "avg_pool2d_backward",
    "overload": "grad_input",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:kernel_size|stride|padding|divisor_override,view_like",
    "schema": "aten::avg_pool2d_backward.grad_input(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride, int[2] padding, bool ceil_mode, bool count_include_pad, int? divisor_override, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "avg_pool3d",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:kernel_size|divisor_override,view_like",
    "schema": "aten::avg_pool3d(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, bool ceil_mode=False, bool count_include_pad=True, int? divisor_override=None) -> Tensor"
  },
  {
    "op": "avg_pool3d",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:kernel_size|divisor_override,view_like",
    "schema": "aten::avg_pool3d.out(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, bool ceil_mode=False, bool count_include_pad=True, int? divisor_override=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "avg_pool3d_backward",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:kernel_size|stride|padding|divisor_override,view_like",
    "schema": "aten::avg_pool3d_backward(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] stride, int[3] padding, bool ceil_mode, bool count_include_pad, int? divisor_override) -> Tensor"
  },
  {
    "op": "avg_pool3d_backward",
    "overload": "grad_input",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:kernel_size|stride|padding|divisor_override,view_like",
    "schema": "aten::avg_pool3d_backward.grad_input(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] stride, int[3] padding, bool ceil_mode, bool count_include_pad, int? divisor_override, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "baddbmm",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::baddbmm(Tensor self, Tensor batch1, Tensor batch2, *, Scalar beta=1, Scalar alpha=1) -> Tensor"
  },
  {
    "op": "baddbmm",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::baddbmm.out(Tensor self, Tensor batch1, Tensor batch2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "baddbmm",
    "overload": "dtype_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_ready,view_like",
    "schema": "aten::baddbmm.dtype_out(Tensor self, Tensor batch1, Tensor batch2, ScalarType out_dtype, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "baddbmm",
    "overload": "dtype",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_ready,view_like",
    "schema": "aten::baddbmm.dtype(Tensor self, Tensor batch1, Tensor batch2, ScalarType out_dtype, *, Scalar beta=1, Scalar alpha=1) -> Tensor"
  },
  {
    "op": "baddbmm_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::baddbmm_(Tensor(a!) self, Tensor batch1, Tensor batch2, *, Scalar beta=1, Scalar alpha=1) -> Tensor(a!)"
  },
  {
    "op": "batch_norm_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_mask,view_like",
    "schema": "aten::batch_norm_backward(Tensor grad_out, Tensor input, Tensor weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var, bool update, float eps, bool[3] output_mask, Tensor reserve) -> (Tensor, Tensor, Tensor)"
  },
  {
    "op": "bernoulli",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,random,view_like",
    "schema": "aten::bernoulli(Tensor self, *, Generator? generator=None) -> Tensor"
  },
  {
    "op": "bernoulli",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,random,view_like",
    "schema": "aten::bernoulli.out(Tensor self, *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bernoulli",
    "overload": "p",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,random",
    "schema": "aten::bernoulli.p(Tensor self, float p, *, Generator? generator=None) -> Tensor"
  },
  {
    "op": "bernoulli",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,random,view_like",
    "schema": "aten::bernoulli.Tensor(Tensor self, Tensor p, *, Generator? generator=None) -> Tensor"
  },
  {
    "op": "bernoulli",
    "overload": "Tensor_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,random,view_like",
    "schema": "aten::bernoulli.Tensor_out(Tensor self, Tensor p, *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bernoulli",
    "overload": "float_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,random,view_like",
    "schema": "aten::bernoulli.float_out(Tensor self, float p=0.5, *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bernoulli_",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:generator,random,view_like",
    "schema": "aten::bernoulli_.Tensor(Tensor(a!) self, Tensor p, *, Generator? generator=None) -> Tensor(a!)"
  },
  {
    "op": "bernoulli_",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:generator,random,view_like",
    "schema": "aten::bernoulli_.float(Tensor(a!) self, float p=0.5, *, Generator? generator=None) -> Tensor(a!)"
  },
  {
    "op": "binary_cross_entropy",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::binary_cross_entropy(Tensor self, Tensor target, Tensor? weight=None, int reduction=1) -> Tensor"
  },
  {
    "op": "binary_cross_entropy",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::binary_cross_entropy.out(Tensor self, Tensor target, Tensor? weight=None, int reduction=1, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "binary_cross_entropy_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::binary_cross_entropy_backward(Tensor grad_output, Tensor self, Tensor target, Tensor? weight=None, int reduction=1) -> Tensor"
  },
  {
    "op": "binary_cross_entropy_backward",
    "overload": "grad_input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::binary_cross_entropy_backward.grad_input(Tensor grad_output, Tensor self, Tensor target, Tensor? weight=None, int reduction=1, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "binary_cross_entropy_with_logits",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::binary_cross_entropy_with_logits(Tensor self, Tensor target, Tensor? weight=None, Tensor? pos_weight=None, int reduction=1) -> Tensor"
  },
  {
    "op": "binary_cross_entropy_with_logits",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::binary_cross_entropy_with_logits.out(Tensor self, Tensor target, Tensor? weight=None, Tensor? pos_weight=None, int reduction=1, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bincount",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::bincount(Tensor self, Tensor? weights=None, SymInt minlength=0) -> Tensor"
  },
  {
    "op": "bincount",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::bincount.out(Tensor self, Tensor? weights=None, SymInt minlength=0, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bitwise_and",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::bitwise_and.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "bitwise_and",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::bitwise_and.Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "bitwise_and",
    "overload": "Scalar_Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self,view_like",
    "schema": "aten::bitwise_and.Scalar_Tensor(Scalar self, Tensor other) -> Tensor"
  },
  {
    "op": "bitwise_and",
    "overload": "Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::bitwise_and.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bitwise_and",
    "overload": "Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::bitwise_and.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bitwise_and",
    "overload": "Scalar_Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self,view_like",
    "schema": "aten::bitwise_and.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bitwise_and_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::bitwise_and_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "bitwise_and_",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other,view_like",
    "schema": "aten::bitwise_and_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "bitwise_left_shift",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::bitwise_left_shift.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "bitwise_left_shift",
    "overload": "Tensor_Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::bitwise_left_shift.Tensor_Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "bitwise_left_shift",
    "overload": "Scalar_Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self,view_like",
    "schema": "aten::bitwise_left_shift.Scalar_Tensor(Scalar self, Tensor other) -> Tensor"
  },
  {
    "op": "bitwise_left_shift",
    "overload": "Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::bitwise_left_shift.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bitwise_left_shift",
    "overload": "Tensor_Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::bitwise_left_shift.Tensor_Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bitwise_left_shift",
    "overload": "Scalar_Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self,view_like",
    "schema": "aten::bitwise_left_shift.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bitwise_left_shift_",
    "overload": "Tensor_Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other,view_like",
    "schema": "aten::bitwise_left_shift_.Tensor_Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "bitwise_left_shift_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::bitwise_left_shift_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "bitwise_not",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::bitwise_not(Tensor self) -> Tensor"
  },
  {
    "op": "bitwise_not",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::bitwise_not.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bitwise_not_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::bitwise_not_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "bitwise_or",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::bitwise_or.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "bitwise_or",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::bitwise_or.Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "bitwise_or",
    "overload": "Scalar_Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self,view_like",
    "schema": "aten::bitwise_or.Scalar_Tensor(Scalar self, Tensor other) -> Tensor"
  },
  {
    "op": "bitwise_or",
    "overload": "Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::bitwise_or.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bitwise_or",
    "overload": "Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::bitwise_or.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bitwise_or",
    "overload": "Scalar_Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self,view_like",
    "schema": "aten::bitwise_or.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bitwise_or_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::bitwise_or_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "bitwise_or_",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other,view_like",
    "schema": "aten::bitwise_or_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "bitwise_right_shift",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::bitwise_right_shift.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "bitwise_right_shift",
    "overload": "Tensor_Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::bitwise_right_shift.Tensor_Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "bitwise_right_shift",
    "overload": "Scalar_Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self,view_like",
    "schema": "aten::bitwise_right_shift.Scalar_Tensor(Scalar self, Tensor other) -> Tensor"
  },
  {
    "op": "bitwise_right_shift",
    "overload": "Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::bitwise_right_shift.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bitwise_right_shift",
    "overload": "Tensor_Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::bitwise_right_shift.Tensor_Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bitwise_right_shift",
    "overload": "Scalar_Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self,view_like",
    "schema": "aten::bitwise_right_shift.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bitwise_right_shift_",
    "overload": "Tensor_Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other,view_like",
    "schema": "aten::bitwise_right_shift_.Tensor_Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "bitwise_right_shift_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::bitwise_right_shift_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "bitwise_xor",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::bitwise_xor.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "bitwise_xor",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::bitwise_xor.Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "bitwise_xor",
    "overload": "Scalar_Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self,view_like",
    "schema": "aten::bitwise_xor.Scalar_Tensor(Scalar self, Tensor other) -> Tensor"
  },
  {
    "op": "bitwise_xor",
    "overload": "Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::bitwise_xor.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bitwise_xor",
    "overload": "Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::bitwise_xor.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bitwise_xor",
    "overload": "Scalar_Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self,view_like",
    "schema": "aten::bitwise_xor.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bitwise_xor_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::bitwise_xor_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "bitwise_xor_",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other,view_like",
    "schema": "aten::bitwise_xor_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "block_diag",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::block_diag(Tensor[] tensors) -> Tensor"
  },
  {
    "op": "block_diag",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::block_diag.out(Tensor[] tensors, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bmm",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::bmm(Tensor self, Tensor mat2) -> Tensor"
  },
  {
    "op": "bmm",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::bmm.out(Tensor self, Tensor mat2, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bmm",
    "overload": "dtype_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_ready,view_like",
    "schema": "aten::bmm.dtype_out(Tensor self, Tensor mat2, ScalarType out_dtype, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bmm",
    "overload": "dtype",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_ready,view_like",
    "schema": "aten::bmm.dtype(Tensor self, Tensor mat2, ScalarType out_dtype) -> Tensor"
  },
  {
    "op": "broadcast_tensors",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::broadcast_tensors(Tensor[] tensors) -> Tensor[]"
  },
  {
    "op": "bucketize",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::bucketize.Tensor(Tensor self, Tensor boundaries, *, bool out_int32=False, bool right=False) -> Tensor"
  },
  {
    "op": "bucketize",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self,view_like",
    "schema": "aten::bucketize.Scalar(Scalar self, Tensor boundaries, *, bool out_int32=False, bool right=False) -> Tensor"
  },
  {
    "op": "bucketize",
    "overload": "Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::bucketize.Tensor_out(Tensor self, Tensor boundaries, *, bool out_int32=False, bool right=False, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "bucketize",
    "overload": "Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self,view_like",
    "schema": "aten::bucketize.Scalar_out(Scalar self, Tensor boundaries, *, bool out_int32=False, bool right=False, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "cat",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::cat(Tensor[] tensors, int dim=0) -> Tensor"
  },
  {
    "op": "cat",
    "overload": "names",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::cat.names(Tensor[] tensors, str dim) -> Tensor"
  },
  {
    "op": "cat",
    "overload": "names_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::cat.names_out(Tensor[] tensors, str dim, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "cat",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::cat.out(Tensor[] tensors, int dim=0, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "cauchy",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,view_like",
    "schema": "aten::cauchy(Tensor self, float median=0., float sigma=1., *, Generator? generator=None) -> Tensor"
  },
  {
    "op": "cauchy",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,view_like",
    "schema": "aten::cauchy.out(Tensor self, float median=0., float sigma=1., *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "cauchy_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:generator,view_like",
    "schema": "aten::cauchy_(Tensor(a!) self, float median=0., float sigma=1., *, Generator? generator=None) -> Tensor(a!)"
  },
  {
    "op": "ceil",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::ceil(Tensor self) -> Tensor"
  },
  {
    "op": "ceil",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::ceil.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "ceil",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::ceil.int(int a) -> int"
  },
  {
    "op": "ceil",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::ceil.float(float a) -> int"
  },
  {
    "op": "ceil",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::ceil.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "ceil_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::ceil_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "celu",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::celu(Tensor self, Scalar alpha=1.) -> Tensor"
  },
  {
    "op": "celu",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::celu.out(Tensor self, Scalar alpha=1., *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "celu_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::celu_(Tensor(a!) self, Scalar alpha=1.) -> Tensor(a!)"
  },
  {
    "op": "channel_shuffle",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::channel_shuffle(Tensor self, SymInt groups) -> Tensor"
  },
  {
    "op": "channel_shuffle",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::channel_shuffle.out(Tensor self, SymInt groups, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "cholesky",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::cholesky(Tensor self, bool upper=False) -> Tensor"
  },
  {
    "op": "cholesky",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::cholesky.out(Tensor self, bool upper=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "cholesky_inverse",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::cholesky_inverse(Tensor self, bool upper=False) -> Tensor"
  },
  {
    "op": "cholesky_inverse",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::cholesky_inverse.out(Tensor self, bool upper=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "cholesky_solve",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::cholesky_solve(Tensor self, Tensor input2, bool upper=False) -> Tensor"
  },
  {
    "op": "cholesky_solve",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::cholesky_solve.out(Tensor self, Tensor input2, bool upper=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "clamp",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:min|max,view_like",
    "schema": "aten::clamp(Tensor self, Scalar? min=None, Scalar? max=None) -> Tensor"
  },
  {
    "op": "clamp",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::clamp.Tensor(Tensor self, Tensor? min=None, Tensor? max=None) -> Tensor"
  },
  {
    "op": "clamp",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:min|max,view_like",
    "schema": "aten::clamp.out(Tensor self, Scalar? min=None, Scalar? max=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "clamp",
    "overload": "Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::clamp.Tensor_out(Tensor self, Tensor? min=None, Tensor? max=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "clamp_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:min|max,view_like",
    "schema": "aten::clamp_(Tensor(a!) self, Scalar? min=None, Scalar? max=None) -> Tensor(a!)"
  },
  {
    "op": "clamp_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::clamp_.Tensor(Tensor(a!) self, Tensor? min=None, Tensor? max=None) -> Tensor(a!)"
  },
  {
    "op": "clamp_max",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:max,view_like",
    "schema": "aten::clamp_max(Tensor self, Scalar max) -> Tensor"
  },
  {
    "op": "clamp_max",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::clamp_max.Tensor(Tensor self, Tensor max) -> Tensor"
  },
  {
    "op": "clamp_max",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:max,view_like",
    "schema": "aten::clamp_max.out(Tensor self, Scalar max, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "clamp_max",
    "overload": "Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::clamp_max.Tensor_out(Tensor self, Tensor max, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "clamp_max_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:max,view_like",
    "schema": "aten::clamp_max_(Tensor(a!) self, Scalar max) -> Tensor(a!)"
  },
  {
    "op": "clamp_max_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::clamp_max_.Tensor(Tensor(a!) self, Tensor max) -> Tensor(a!)"
  },
  {
    "op": "clamp_min",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:min,view_like",
    "schema": "aten::clamp_min(Tensor self, Scalar min) -> Tensor"
  },
  {
    "op": "clamp_min",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::clamp_min.Tensor(Tensor self, Tensor min) -> Tensor"
  },
  {
    "op": "clamp_min",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:min,view_like",
    "schema": "aten::clamp_min.out(Tensor self, Scalar min, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "clamp_min",
    "overload": "Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::clamp_min.Tensor_out(Tensor self, Tensor min, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "clamp_min_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:min,view_like",
    "schema": "aten::clamp_min_(Tensor(a!) self, Scalar min) -> Tensor(a!)"
  },
  {
    "op": "clamp_min_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::clamp_min_.Tensor(Tensor(a!) self, Tensor min) -> Tensor(a!)"
  },
  {
    "op": "clip",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:min|max,view_like",
    "schema": "aten::clip(Tensor self, Scalar? min=None, Scalar? max=None) -> Tensor"
  },
  {
    "op": "clip",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::clip.Tensor(Tensor self, Tensor? min=None, Tensor? max=None) -> Tensor"
  },
  {
    "op": "clip",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:min|max,view_like",
    "schema": "aten::clip.out(Tensor self, Scalar? min=None, Scalar? max=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "clip",
    "overload": "Tensor_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::clip.Tensor_out(Tensor self, Tensor? min=None, Tensor? max=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "clip_",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:min|max,view_like",
    "schema": "aten::clip_(Tensor(a!) self, Scalar? min=None, Scalar? max=None) -> Tensor(a!)"
  },
  {
    "op": "clip_",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::clip_.Tensor(Tensor(a!) self, Tensor? min=None, Tensor? max=None) -> Tensor(a!)"
  },
  {
    "op": "clone",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:memory_format,view_like",
    "schema": "aten::clone(Tensor self, *, MemoryFormat? memory_format=None) -> Tensor"
  },
  {
    "op": "clone",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:memory_format,view_like",
    "schema": "aten::clone.out(Tensor self, *, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "col2im",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|kernel_size|dilation|padding|stride,view_like",
    "schema": "aten::col2im(Tensor self, SymInt[2] output_size, int[2] kernel_size, int[2] dilation, int[2] padding, int[2] stride) -> Tensor"
  },
  {
    "op": "col2im",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|kernel_size|dilation|padding|stride,view_like",
    "schema": "aten::col2im.out(Tensor self, SymInt[2] output_size, int[2] kernel_size, int[2] dilation, int[2] padding, int[2] stride, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "complex",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::complex(Tensor real, Tensor imag) -> Tensor"
  },
  {
    "op": "complex",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::complex.out(Tensor real, Tensor imag, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "conj",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::conj(Tensor(a) self) -> Tensor(a)"
  },
  {
    "op": "conj_physical",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::conj_physical(Tensor self) -> Tensor"
  },
  {
    "op": "conj_physical",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::conj_physical.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "conj_physical_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::conj_physical_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "constant_pad_nd",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:pad,view_like",
    "schema": "aten::constant_pad_nd(Tensor self, SymInt[] pad, Scalar value=0) -> Tensor"
  },
  {
    "op": "constant_pad_nd",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:pad,view_like",
    "schema": "aten::constant_pad_nd.out(Tensor self, SymInt[] pad, Scalar value=0, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "conv2d",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::conv2d(Tensor input, Tensor weight, Tensor? bias=None, SymInt[2] stride=[1, 1], SymInt[2] padding=[0, 0], SymInt[2] dilation=[1, 1], SymInt groups=1) -> Tensor"
  },
  {
    "op": "conv2d",
    "overload": "padding",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready",
    "schema": "aten::conv2d.padding(Tensor input, Tensor weight, Tensor? bias=None, SymInt[2] stride=[1, 1], str padding=\"valid\", SymInt[2] dilation=[1, 1], SymInt groups=1) -> Tensor"
  },
  {
    "op": "convolution",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:stride|padding|dilation|output_padding,view_like",
    "schema": "aten::convolution(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups) -> Tensor"
  },
  {
    "op": "convolution",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:stride|padding|dilation|output_padding,view_like",
    "schema": "aten::convolution.out(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "convolution_backward",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:bias_sizes|stride|padding|dilation|output_padding|output_mask,view_like",
    "schema": "aten::convolution_backward(Tensor grad_output, Tensor input, Tensor weight, SymInt[]? bias_sizes, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool[3] output_mask) -> (Tensor, Tensor, Tensor)"
  },
  {
    "op": "convolution_backward",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:bias_sizes|stride|padding|dilation|output_padding|output_mask,view_like",
    "schema": "aten::convolution_backward.out(Tensor grad_output, Tensor input, Tensor weight, SymInt[]? bias_sizes, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool[3] output_mask, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))"
  },
  {
    "op": "copy",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::copy(Tensor self, Tensor src, bool non_blocking=False) -> Tensor"
  },
  {
    "op": "copy",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::copy.out(Tensor self, Tensor src, bool non_blocking=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "copy",
    "overload": "t",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self,view_like",
    "schema": "aten::copy.t(t[](a) self) -> t[]"
  },
  {
    "op": "copy",
    "overload": "Dict_str",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self,view_like",
    "schema": "aten::copy.Dict_str(Dict(str, t)(a) self) -> Dict(str, t)"
  },
  {
    "op": "copy",
    "overload": "Dict_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self,view_like",
    "schema": "aten::copy.Dict_int(Dict(int, t)(a) self) -> Dict(int, t)"
  },
  {
    "op": "copy",
    "overload": "Dict_bool",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self,view_like",
    "schema": "aten::copy.Dict_bool(Dict(bool, t)(a) self) -> Dict(bool, t)"
  },
  {
    "op": "copy",
    "overload": "Dict_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self,view_like",
    "schema": "aten::copy.Dict_float(Dict(float, t)(a) self) -> Dict(float, t)"
  },
  {
    "op": "copy",
    "overload": "Dict_complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self,view_like",
    "schema": "aten::copy.Dict_complex(Dict(complex, t)(a) self) -> Dict(complex, t)"
  },
  {
    "op": "copy",
    "overload": "Dict_Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::copy.Dict_Tensor(Dict(Tensor, t)(a) self) -> Dict(Tensor, t)"
  },
  {
    "op": "copy_",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::copy_(Tensor(a!) self, Tensor src, bool non_blocking=False) -> Tensor(a!)"
  },
  {
    "op": "copy_",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::copy_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "copy_",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::copy_.int(Tensor(a!) self, int other) -> Tensor(a!)"
  },
  {
    "op": "copy_",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::copy_.float(Tensor(a!) self, float other) -> Tensor(a!)"
  },
  {
    "op": "copysign",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::copysign.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "copysign",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other",
    "schema": "aten::copysign.Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "copysign",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::copysign.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "copysign",
    "overload": "Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::copysign.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "copysign",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::copysign.int(int a, int b) -> float"
  },
  {
    "op": "copysign",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::copysign.float(float a, float b) -> float"
  },
  {
    "op": "copysign",
    "overload": "int_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::copysign.int_float(int a, float b) -> float"
  },
  {
    "op": "copysign",
    "overload": "float_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::copysign.float_int(float a, int b) -> float"
  },
  {
    "op": "copysign",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::copysign(Scalar a, Scalar b) -> float"
  },
  {
    "op": "copysign_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::copysign_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "copysign_",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other",
    "schema": "aten::copysign_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "cos",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::cos(Tensor self) -> Tensor"
  },
  {
    "op": "cos",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::cos.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "cos",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::cos.int(int a) -> float"
  },
  {
    "op": "cos",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::cos.float(float a) -> float"
  },
  {
    "op": "cos",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::cos.complex(complex a) -> complex"
  },
  {
    "op": "cos",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::cos.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "cos_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::cos_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "cosh",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::cosh(Tensor self) -> Tensor"
  },
  {
    "op": "cosh",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::cosh.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "cosh",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::cosh.int(int a) -> float"
  },
  {
    "op": "cosh",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::cosh.float(float a) -> float"
  },
  {
    "op": "cosh",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::cosh.complex(complex a) -> complex"
  },
  {
    "op": "cosh",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::cosh.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "cosh_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::cosh_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "count_nonzero",
    "overload": "dim_IntList",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::count_nonzero.dim_IntList(Tensor self, int[] dim) -> Tensor"
  },
  {
    "op": "count_nonzero",
    "overload": "dim_IntList_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::count_nonzero.dim_IntList_out(Tensor self, int[] dim, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "count_nonzero",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::count_nonzero(Tensor self, int? dim=None) -> Tensor"
  },
  {
    "op": "count_nonzero",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::count_nonzero.out(Tensor self, int? dim=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "cudnn_batch_norm",
    "overload": "default",
    "has_decomp": true,
    "devices": "cuda",
    "dtypes": "tensor",
    "notes": "cuda_only,input_ready,view_like",
    "schema": "aten::cudnn_batch_norm(Tensor input, Tensor weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float exponential_average_factor, float epsilon) -> (Tensor, Tensor, Tensor, Tensor)"
  },
  {
    "op": "cudnn_batch_norm",
    "overload": "out",
    "has_decomp": true,
    "devices": "cuda",
    "dtypes": "tensor",
    "notes": "cuda_only,input_ready,view_like",
    "schema": "aten::cudnn_batch_norm.out(Tensor input, Tensor weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float exponential_average_factor, float epsilon, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2, Tensor(d!) out3) -> (Tensor(a!), Tensor(b!), Tensor(c!), Tensor(d!))"
  },
  {
    "op": "cudnn_batch_norm_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "cuda",
    "dtypes": "tensor",
    "notes": "cuda_only,input_ready,view_like",
    "schema": "aten::cudnn_batch_norm_backward(Tensor input, Tensor grad_output, Tensor weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var, float epsilon, Tensor reserveSpace) -> (Tensor, Tensor, Tensor)"
  },
  {
    "op": "cudnn_batch_norm_backward",
    "overload": "out",
    "has_decomp": true,
    "devices": "cuda",
    "dtypes": "tensor",
    "notes": "cuda_only,input_ready,view_like",
    "schema": "aten::cudnn_batch_norm_backward.out(Tensor input, Tensor grad_output, Tensor weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var, float epsilon, Tensor reserveSpace, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))"
  },
  {
    "op": "cummax",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::cummax(Tensor self, int dim) -> (Tensor values, Tensor indices)"
  },
  {
    "op": "cummax",
    "overload": "dimname",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::cummax.dimname(Tensor self, str dim) -> (Tensor values, Tensor indices)"
  },
  {
    "op": "cummax",
    "overload": "dimname_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::cummax.dimname_out(Tensor self, str dim, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)"
  },
  {
    "op": "cummax",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::cummax.out(Tensor self, int dim, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)"
  },
  {
    "op": "cummin",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::cummin(Tensor self, int dim) -> (Tensor values, Tensor indices)"
  },
  {
    "op": "cummin",
    "overload": "dimname",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::cummin.dimname(Tensor self, str dim) -> (Tensor values, Tensor indices)"
  },
  {
    "op": "cummin",
    "overload": "dimname_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::cummin.dimname_out(Tensor self, str dim, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)"
  },
  {
    "op": "cummin",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::cummin.out(Tensor self, int dim, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)"
  },
  {
    "op": "cumprod",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype,view_like",
    "schema": "aten::cumprod(Tensor self, int dim, *, ScalarType? dtype=None) -> Tensor"
  },
  {
    "op": "cumprod",
    "overload": "dimname",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dim|dtype",
    "schema": "aten::cumprod.dimname(Tensor self, str dim, *, ScalarType? dtype=None) -> Tensor"
  },
  {
    "op": "cumprod",
    "overload": "dimname_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dim|dtype,view_like",
    "schema": "aten::cumprod.dimname_out(Tensor self, str dim, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "cumprod",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype,view_like",
    "schema": "aten::cumprod.out(Tensor self, int dim, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "cumprod_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "inplace,input_missing:dtype,view_like",
    "schema": "aten::cumprod_(Tensor(a!) self, int dim, *, ScalarType? dtype=None) -> Tensor(a!)"
  },
  {
    "op": "cumprod_",
    "overload": "dimname",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "inplace,input_missing:dim|dtype",
    "schema": "aten::cumprod_.dimname(Tensor(a!) self, str dim, *, ScalarType? dtype=None) -> Tensor(a!)"
  },
  {
    "op": "cumsum",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype,view_like",
    "schema": "aten::cumsum(Tensor self, int dim, *, ScalarType? dtype=None) -> Tensor"
  },
  {
    "op": "cumsum",
    "overload": "dimname",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dim|dtype",
    "schema": "aten::cumsum.dimname(Tensor self, str dim, *, ScalarType? dtype=None) -> Tensor"
  },
  {
    "op": "cumsum",
    "overload": "dimname_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dim|dtype,view_like",
    "schema": "aten::cumsum.dimname_out(Tensor self, str dim, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "cumsum",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype,view_like",
    "schema": "aten::cumsum.out(Tensor self, int dim, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "cumsum_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "inplace,input_missing:dtype,view_like",
    "schema": "aten::cumsum_(Tensor(a!) self, int dim, *, ScalarType? dtype=None) -> Tensor(a!)"
  },
  {
    "op": "cumsum_",
    "overload": "dimname",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "inplace,input_missing:dim|dtype",
    "schema": "aten::cumsum_.dimname(Tensor(a!) self, str dim, *, ScalarType? dtype=None) -> Tensor(a!)"
  },
  {
    "op": "deg2rad",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::deg2rad(Tensor self) -> Tensor"
  },
  {
    "op": "deg2rad",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::deg2rad.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "deg2rad_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::deg2rad_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "dense_dim",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::dense_dim(Tensor self) -> int"
  },
  {
    "op": "detach",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::detach(Tensor(a) self) -> Tensor(a)"
  },
  {
    "op": "diag",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::diag(Tensor self, int diagonal=0) -> Tensor"
  },
  {
    "op": "diag",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::diag.out(Tensor self, int diagonal=0, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "diag_embed",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::diag_embed(Tensor self, int offset=0, int dim1=-2, int dim2=-1) -> Tensor"
  },
  {
    "op": "diag_embed",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::diag_embed.out(Tensor self, int offset=0, int dim1=-2, int dim2=-1, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "diagonal",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::diagonal(Tensor(a) self, int offset=0, int dim1=0, int dim2=1) -> Tensor(a)"
  },
  {
    "op": "diagonal",
    "overload": "Dimname",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:outdim|dim1|dim2",
    "schema": "aten::diagonal.Dimname(Tensor(a) self, *, str outdim, str dim1, str dim2, int offset=0) -> Tensor(a)"
  },
  {
    "op": "diagonal_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:input_sizes,view_like",
    "schema": "aten::diagonal_backward(Tensor grad_output, SymInt[] input_sizes, int offset, int dim1, int dim2) -> Tensor"
  },
  {
    "op": "diagonal_backward",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:input_sizes,view_like",
    "schema": "aten::diagonal_backward.out(Tensor grad_output, SymInt[] input_sizes, int offset, int dim1, int dim2, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "diagonal_copy",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::diagonal_copy(Tensor self, int offset=0, int dim1=0, int dim2=1) -> Tensor"
  },
  {
    "op": "diagonal_copy",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::diagonal_copy.out(Tensor self, int offset=0, int dim1=0, int dim2=1, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "diagonal_scatter",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::diagonal_scatter(Tensor self, Tensor src, int offset=0, int dim1=0, int dim2=1) -> Tensor"
  },
  {
    "op": "diagonal_scatter",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::diagonal_scatter.out(Tensor self, Tensor src, int offset=0, int dim1=0, int dim2=1, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "digamma",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::digamma(Tensor self) -> Tensor"
  },
  {
    "op": "digamma",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::digamma.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "digamma_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::digamma_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "dim",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::dim(Tensor self) -> int"
  },
  {
    "op": "dist",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::dist(Tensor self, Tensor other, Scalar p=2) -> Tensor"
  },
  {
    "op": "dist",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::dist.out(Tensor self, Tensor other, Scalar p=2, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "div",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::div.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "div",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other",
    "schema": "aten::div.Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "div",
    "overload": "Tensor_mode",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:rounding_mode,view_like",
    "schema": "aten::div.Tensor_mode(Tensor self, Tensor other, *, str? rounding_mode) -> Tensor"
  },
  {
    "op": "div",
    "overload": "Scalar_mode",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other|rounding_mode",
    "schema": "aten::div.Scalar_mode(Tensor self, Scalar other, *, str? rounding_mode) -> Tensor"
  },
  {
    "op": "div",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::div.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "div",
    "overload": "out_mode",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:rounding_mode,view_like",
    "schema": "aten::div.out_mode(Tensor self, Tensor other, *, str? rounding_mode, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "div",
    "overload": "Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::div.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "div",
    "overload": "Scalar_mode_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other|rounding_mode,view_like",
    "schema": "aten::div.Scalar_mode_out(Tensor self, Scalar other, *, str? rounding_mode, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "div",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::div.int(int a, int b) -> float"
  },
  {
    "op": "div",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b",
    "schema": "aten::div.complex(complex a, complex b) -> complex"
  },
  {
    "op": "div",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::div.float(float a, float b) -> float"
  },
  {
    "op": "div",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::div(Scalar a, Scalar b) -> float"
  },
  {
    "op": "div_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::div_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "div_",
    "overload": "Tensor_mode",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:rounding_mode,view_like",
    "schema": "aten::div_.Tensor_mode(Tensor(a!) self, Tensor other, *, str? rounding_mode) -> Tensor(a!)"
  },
  {
    "op": "div_",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other",
    "schema": "aten::div_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "div_",
    "overload": "Scalar_mode",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other|rounding_mode",
    "schema": "aten::div_.Scalar_mode(Tensor(a!) self, Scalar other, *, str? rounding_mode) -> Tensor(a!)"
  },
  {
    "op": "divide",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::divide.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "divide",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other",
    "schema": "aten::divide.Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "divide",
    "overload": "Tensor_mode",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:rounding_mode,view_like",
    "schema": "aten::divide.Tensor_mode(Tensor self, Tensor other, *, str? rounding_mode) -> Tensor"
  },
  {
    "op": "divide",
    "overload": "Scalar_mode",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other|rounding_mode",
    "schema": "aten::divide.Scalar_mode(Tensor self, Scalar other, *, str? rounding_mode) -> Tensor"
  },
  {
    "op": "divide",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::divide.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "divide",
    "overload": "out_mode",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:rounding_mode,view_like",
    "schema": "aten::divide.out_mode(Tensor self, Tensor other, *, str? rounding_mode, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "divide_",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::divide_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "divide_",
    "overload": "Tensor_mode",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:rounding_mode,view_like",
    "schema": "aten::divide_.Tensor_mode(Tensor(a!) self, Tensor other, *, str? rounding_mode) -> Tensor(a!)"
  },
  {
    "op": "divide_",
    "overload": "Scalar_mode",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other|rounding_mode",
    "schema": "aten::divide_.Scalar_mode(Tensor(a!) self, Scalar other, *, str? rounding_mode) -> Tensor(a!)"
  },
  {
    "op": "divide_",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other",
    "schema": "aten::divide_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "dot",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::dot(Tensor self, Tensor tensor) -> Tensor"
  },
  {
    "op": "dot",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::dot.out(Tensor self, Tensor tensor, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "dropout",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,random,view_like",
    "schema": "aten::dropout(Tensor input, float p, bool train) -> Tensor"
  },
  {
    "op": "elu",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::elu(Tensor self, Scalar alpha=1, Scalar scale=1, Scalar input_scale=1) -> Tensor"
  },
  {
    "op": "elu",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::elu.out(Tensor self, Scalar alpha=1, Scalar scale=1, Scalar input_scale=1, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "elu_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::elu_(Tensor(a!) self, Scalar alpha=1, Scalar scale=1, Scalar input_scale=1) -> Tensor(a!)"
  },
  {
    "op": "elu_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:alpha|scale|input_scale,view_like",
    "schema": "aten::elu_backward(Tensor grad_output, Scalar alpha, Scalar scale, Scalar input_scale, bool is_result, Tensor self_or_result) -> Tensor"
  },
  {
    "op": "elu_backward",
    "overload": "grad_input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:alpha|scale|input_scale,view_like",
    "schema": "aten::elu_backward.grad_input(Tensor grad_output, Scalar alpha, Scalar scale, Scalar input_scale, bool is_result, Tensor self_or_result, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "embedding",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::embedding(Tensor weight, Tensor indices, SymInt padding_idx=-1, bool scale_grad_by_freq=False, bool sparse=False) -> Tensor"
  },
  {
    "op": "embedding",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::embedding.out(Tensor weight, Tensor indices, SymInt padding_idx=-1, bool scale_grad_by_freq=False, bool sparse=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "embedding_dense_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::embedding_dense_backward(Tensor grad_output, Tensor indices, SymInt num_weights, SymInt padding_idx, bool scale_grad_by_freq) -> Tensor"
  },
  {
    "op": "embedding_dense_backward",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::embedding_dense_backward.out(Tensor grad_output, Tensor indices, SymInt num_weights, SymInt padding_idx, bool scale_grad_by_freq, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "empty",
    "overload": "memory_format",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|dtype|layout|pin_memory|memory_format,view_like",
    "schema": "aten::empty.memory_format(SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, MemoryFormat? memory_format=None) -> Tensor"
  },
  {
    "op": "empty",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|memory_format,view_like",
    "schema": "aten::empty.out(SymInt[] size, *, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "empty",
    "overload": "names",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|names|dtype|layout|pin_memory|memory_format,view_like",
    "schema": "aten::empty.names(int[] size, *, str[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, MemoryFormat? memory_format=None) -> Tensor"
  },
  {
    "op": "empty",
    "overload": "names_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|names|memory_format,view_like",
    "schema": "aten::empty.names_out(int[] size, *, str[]? names, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "empty_like",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype|layout|pin_memory|memory_format,view_like",
    "schema": "aten::empty_like(Tensor self, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, MemoryFormat? memory_format=None) -> Tensor"
  },
  {
    "op": "empty_like",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:memory_format,view_like",
    "schema": "aten::empty_like.out(Tensor self, *, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "empty_permuted",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|physical_layout|dtype|layout|pin_memory,view_like",
    "schema": "aten::empty_permuted(SymInt[] size, int[] physical_layout, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "empty_permuted",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|physical_layout,view_like",
    "schema": "aten::empty_permuted.out(SymInt[] size, int[] physical_layout, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "empty_strided",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|stride|dtype|layout|pin_memory,view_like",
    "schema": "aten::empty_strided(SymInt[] size, SymInt[] stride, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "empty_strided",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|stride,view_like",
    "schema": "aten::empty_strided.out(SymInt[] size, SymInt[] stride, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "eq",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::eq.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "eq",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other",
    "schema": "aten::eq.Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "eq",
    "overload": "Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::eq.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "eq",
    "overload": "Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::eq.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "eq",
    "overload": "int_list",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::eq.int_list(int[] a, int[] b) -> bool"
  },
  {
    "op": "eq",
    "overload": "device",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready",
    "schema": "aten::eq.device(Device a, Device b) -> bool"
  },
  {
    "op": "eq",
    "overload": "bool",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready",
    "schema": "aten::eq.bool(bool a, bool b) -> bool"
  },
  {
    "op": "eq",
    "overload": "enum",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b",
    "schema": "aten::eq.enum(AnyEnumType a, AnyEnumType b) -> bool"
  },
  {
    "op": "eq",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::eq.int(int a, int b) -> bool"
  },
  {
    "op": "eq",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b",
    "schema": "aten::eq.complex(complex a, complex b) -> bool"
  },
  {
    "op": "eq",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::eq.float(float a, float b) -> bool"
  },
  {
    "op": "eq",
    "overload": "int_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::eq.int_float(int a, float b) -> bool"
  },
  {
    "op": "eq",
    "overload": "float_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::eq.float_int(float a, int b) -> bool"
  },
  {
    "op": "eq",
    "overload": "float_complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:b,view_like",
    "schema": "aten::eq.float_complex(float a, complex b) -> bool"
  },
  {
    "op": "eq",
    "overload": "complex_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a,view_like",
    "schema": "aten::eq.complex_float(complex a, float b) -> bool"
  },
  {
    "op": "eq",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::eq(Scalar a, Scalar b) -> bool"
  },
  {
    "op": "eq",
    "overload": "str",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::eq.str(str a, str b) -> bool"
  },
  {
    "op": "eq",
    "overload": "float_list",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::eq.float_list(float[] a, float[] b) -> bool"
  },
  {
    "op": "eq",
    "overload": "Tensor_list",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::eq.Tensor_list(Tensor[] a, Tensor[] b) -> bool"
  },
  {
    "op": "eq",
    "overload": "bool_list",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::eq.bool_list(bool[] a, bool[] b) -> bool"
  },
  {
    "op": "eq",
    "overload": "str_list",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::eq.str_list(str[] a, str[] b) -> bool"
  },
  {
    "op": "eq_",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other",
    "schema": "aten::eq_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "eq_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::eq_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "erf",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::erf(Tensor self) -> Tensor"
  },
  {
    "op": "erf",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::erf.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "erf",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::erf.int(int a) -> float"
  },
  {
    "op": "erf",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::erf.float(float a) -> float"
  },
  {
    "op": "erf",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::erf.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "erf_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::erf_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "erfc",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::erfc(Tensor self) -> Tensor"
  },
  {
    "op": "erfc",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::erfc.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "erfc",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::erfc.int(int a) -> float"
  },
  {
    "op": "erfc",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::erfc.float(float a) -> float"
  },
  {
    "op": "erfc",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::erfc.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "erfc_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::erfc_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "erfinv",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::erfinv(Tensor self) -> Tensor"
  },
  {
    "op": "erfinv",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::erfinv.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "erfinv_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::erfinv_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "exp",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::exp(Tensor self) -> Tensor"
  },
  {
    "op": "exp",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::exp.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "exp",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::exp.int(int a) -> float"
  },
  {
    "op": "exp",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::exp.float(float a) -> float"
  },
  {
    "op": "exp",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::exp.complex(complex a) -> complex"
  },
  {
    "op": "exp",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::exp.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "exp2",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::exp2(Tensor self) -> Tensor"
  },
  {
    "op": "exp2",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::exp2.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "exp2_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::exp2_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "exp_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::exp_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "expand",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size,view_like",
    "schema": "aten::expand(Tensor(a) self, SymInt[] size, *, bool implicit=False) -> Tensor(a)"
  },
  {
    "op": "expand_copy",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size,view_like",
    "schema": "aten::expand_copy(Tensor self, SymInt[] size, *, bool implicit=False) -> Tensor"
  },
  {
    "op": "expand_copy",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size,view_like",
    "schema": "aten::expand_copy.out(Tensor self, SymInt[] size, *, bool implicit=False, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "expm1",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::expm1(Tensor self) -> Tensor"
  },
  {
    "op": "expm1",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::expm1.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "expm1",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::expm1.int(int a) -> float"
  },
  {
    "op": "expm1",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::expm1.float(float a) -> float"
  },
  {
    "op": "expm1",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::expm1.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "expm1_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::expm1_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "exponential",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,view_like",
    "schema": "aten::exponential(Tensor self, float lambd=1., *, Generator? generator=None) -> Tensor"
  },
  {
    "op": "exponential",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,view_like",
    "schema": "aten::exponential.out(Tensor self, float lambd=1., *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "exponential_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:generator,view_like",
    "schema": "aten::exponential_(Tensor(a!) self, float lambd=1., *, Generator? generator=None) -> Tensor(a!)"
  },
  {
    "op": "eye",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype|layout|pin_memory,view_like",
    "schema": "aten::eye(SymInt n, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "eye",
    "overload": "m",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype|layout|pin_memory",
    "schema": "aten::eye.m(SymInt n, SymInt m, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "eye",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::eye.out(SymInt n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "eye",
    "overload": "m_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::eye.m_out(SymInt n, SymInt m, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fft_fft",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n|norm,view_like",
    "schema": "aten::fft_fft(Tensor self, SymInt? n=None, int dim=-1, str? norm=None) -> Tensor"
  },
  {
    "op": "fft_fft",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n|norm,view_like",
    "schema": "aten::fft_fft.out(Tensor self, SymInt? n=None, int dim=-1, str? norm=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fft_fft2",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|norm,view_like",
    "schema": "aten::fft_fft2(Tensor self, SymInt[1]? s=None, int[1] dim=[-2, -1], str? norm=None) -> Tensor"
  },
  {
    "op": "fft_fft2",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|norm,view_like",
    "schema": "aten::fft_fft2.out(Tensor self, SymInt[1]? s=None, int[1] dim=[-2, -1], str? norm=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fft_fftn",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|dim|norm,view_like",
    "schema": "aten::fft_fftn(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None) -> Tensor"
  },
  {
    "op": "fft_fftn",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|dim|norm,view_like",
    "schema": "aten::fft_fftn.out(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fft_fftshift",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::fft_fftshift(Tensor self, int[1]? dim=None) -> Tensor"
  },
  {
    "op": "fft_hfft",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n|norm,view_like",
    "schema": "aten::fft_hfft(Tensor self, SymInt? n=None, int dim=-1, str? norm=None) -> Tensor"
  },
  {
    "op": "fft_hfft",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n|norm,view_like",
    "schema": "aten::fft_hfft.out(Tensor self, SymInt? n=None, int dim=-1, str? norm=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fft_hfft2",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|norm,view_like",
    "schema": "aten::fft_hfft2(Tensor self, SymInt[1]? s=None, int[1] dim=[-2, -1], str? norm=None) -> Tensor"
  },
  {
    "op": "fft_hfft2",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|norm,view_like",
    "schema": "aten::fft_hfft2.out(Tensor self, SymInt[1]? s=None, int[1] dim=[-2, -1], str? norm=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fft_hfftn",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|dim|norm,view_like",
    "schema": "aten::fft_hfftn(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None) -> Tensor"
  },
  {
    "op": "fft_hfftn",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|dim|norm,view_like",
    "schema": "aten::fft_hfftn.out(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fft_ifft",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n|norm,view_like",
    "schema": "aten::fft_ifft(Tensor self, SymInt? n=None, int dim=-1, str? norm=None) -> Tensor"
  },
  {
    "op": "fft_ifft",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n|norm,view_like",
    "schema": "aten::fft_ifft.out(Tensor self, SymInt? n=None, int dim=-1, str? norm=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fft_ifft2",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|norm,view_like",
    "schema": "aten::fft_ifft2(Tensor self, SymInt[1]? s=None, int[1] dim=[-2, -1], str? norm=None) -> Tensor"
  },
  {
    "op": "fft_ifft2",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|norm,view_like",
    "schema": "aten::fft_ifft2.out(Tensor self, SymInt[1]? s=None, int[1] dim=[-2, -1], str? norm=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fft_ifftn",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|dim|norm,view_like",
    "schema": "aten::fft_ifftn(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None) -> Tensor"
  },
  {
    "op": "fft_ifftn",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|dim|norm,view_like",
    "schema": "aten::fft_ifftn.out(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fft_ifftshift",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::fft_ifftshift(Tensor self, int[1]? dim=None) -> Tensor"
  },
  {
    "op": "fft_ihfft",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n|norm,view_like",
    "schema": "aten::fft_ihfft(Tensor self, SymInt? n=None, int dim=-1, str? norm=None) -> Tensor"
  },
  {
    "op": "fft_ihfft",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n|norm,view_like",
    "schema": "aten::fft_ihfft.out(Tensor self, SymInt? n=None, int dim=-1, str? norm=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fft_ihfft2",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|norm,view_like",
    "schema": "aten::fft_ihfft2(Tensor self, SymInt[1]? s=None, int[1] dim=[-2, -1], str? norm=None) -> Tensor"
  },
  {
    "op": "fft_ihfft2",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|norm,view_like",
    "schema": "aten::fft_ihfft2.out(Tensor self, SymInt[1]? s=None, int[1] dim=[-2, -1], str? norm=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fft_ihfftn",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|dim|norm,view_like",
    "schema": "aten::fft_ihfftn(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None) -> Tensor"
  },
  {
    "op": "fft_ihfftn",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|dim|norm,view_like",
    "schema": "aten::fft_ihfftn.out(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fft_irfft",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n|norm,view_like",
    "schema": "aten::fft_irfft(Tensor self, SymInt? n=None, int dim=-1, str? norm=None) -> Tensor"
  },
  {
    "op": "fft_irfft",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n|norm,view_like",
    "schema": "aten::fft_irfft.out(Tensor self, SymInt? n=None, int dim=-1, str? norm=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fft_irfft2",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|norm,view_like",
    "schema": "aten::fft_irfft2(Tensor self, SymInt[1]? s=None, int[1] dim=[-2, -1], str? norm=None) -> Tensor"
  },
  {
    "op": "fft_irfft2",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|norm,view_like",
    "schema": "aten::fft_irfft2.out(Tensor self, SymInt[1]? s=None, int[1] dim=[-2, -1], str? norm=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fft_irfftn",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|dim|norm,view_like",
    "schema": "aten::fft_irfftn(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None) -> Tensor"
  },
  {
    "op": "fft_irfftn",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|dim|norm,view_like",
    "schema": "aten::fft_irfftn.out(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fft_rfft",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n|norm,view_like",
    "schema": "aten::fft_rfft(Tensor self, SymInt? n=None, int dim=-1, str? norm=None) -> Tensor"
  },
  {
    "op": "fft_rfft",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n|norm,view_like",
    "schema": "aten::fft_rfft.out(Tensor self, SymInt? n=None, int dim=-1, str? norm=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fft_rfft2",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|norm,view_like",
    "schema": "aten::fft_rfft2(Tensor self, SymInt[1]? s=None, int[1] dim=[-2, -1], str? norm=None) -> Tensor"
  },
  {
    "op": "fft_rfft2",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|norm,view_like",
    "schema": "aten::fft_rfft2.out(Tensor self, SymInt[1]? s=None, int[1] dim=[-2, -1], str? norm=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fft_rfftn",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|dim|norm,view_like",
    "schema": "aten::fft_rfftn(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None) -> Tensor"
  },
  {
    "op": "fft_rfftn",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s|dim|norm,view_like",
    "schema": "aten::fft_rfftn.out(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fill",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:value",
    "schema": "aten::fill.Scalar(Tensor self, Scalar value) -> Tensor"
  },
  {
    "op": "fill",
    "overload": "Scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:value,view_like",
    "schema": "aten::fill.Scalar_out(Tensor self, Scalar value, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fill",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::fill.Tensor(Tensor self, Tensor value) -> Tensor"
  },
  {
    "op": "fill",
    "overload": "Tensor_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::fill.Tensor_out(Tensor self, Tensor value, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fill_",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:value",
    "schema": "aten::fill_.Scalar(Tensor(a!) self, Scalar value) -> Tensor(a!)"
  },
  {
    "op": "fill_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::fill_.Tensor(Tensor(a!) self, Tensor value) -> Tensor(a!)"
  },
  {
    "op": "fix",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::fix(Tensor self) -> Tensor"
  },
  {
    "op": "fix",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::fix.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fix_",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::fix_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "flip",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dims,view_like",
    "schema": "aten::flip(Tensor self, int[] dims) -> Tensor"
  },
  {
    "op": "flip",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dims,view_like",
    "schema": "aten::flip.out(Tensor self, int[] dims, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "float_power_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::float_power_.Tensor(Tensor(a!) self, Tensor exponent) -> Tensor(a!)"
  },
  {
    "op": "float_power_",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:exponent,view_like",
    "schema": "aten::float_power_.Scalar(Tensor(a!) self, Scalar exponent) -> Tensor(a!)"
  },
  {
    "op": "floor",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::floor(Tensor self) -> Tensor"
  },
  {
    "op": "floor",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::floor.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "floor",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::floor.int(int a) -> int"
  },
  {
    "op": "floor",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::floor.float(float a) -> int"
  },
  {
    "op": "floor",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::floor.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "floor_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::floor_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "floor_divide",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::floor_divide(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "floor_divide",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other",
    "schema": "aten::floor_divide.Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "floor_divide",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::floor_divide.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "floor_divide",
    "overload": "Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::floor_divide.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "floor_divide_",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other",
    "schema": "aten::floor_divide_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "floor_divide_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::floor_divide_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "fmax",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::fmax(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "fmax",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::fmax.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fmin",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::fmin(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "fmin",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::fmin.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fmod",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::fmod.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "fmod",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other",
    "schema": "aten::fmod.Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "fmod",
    "overload": "Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::fmod.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fmod",
    "overload": "Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::fmod.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "fmod",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::fmod.int(int a, int b) -> float"
  },
  {
    "op": "fmod",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::fmod.float(float a, float b) -> float"
  },
  {
    "op": "fmod",
    "overload": "int_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::fmod.int_float(int a, float b) -> float"
  },
  {
    "op": "fmod",
    "overload": "float_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::fmod.float_int(float a, int b) -> float"
  },
  {
    "op": "fmod",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::fmod(Scalar a, Scalar b) -> float"
  },
  {
    "op": "fmod_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::fmod_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "fmod_",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other",
    "schema": "aten::fmod_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "frac",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::frac(Tensor self) -> Tensor"
  },
  {
    "op": "frac",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::frac.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "frac_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::frac_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "fractional_max_pool2d",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:kernel_size|output_size,view_like",
    "schema": "aten::fractional_max_pool2d(Tensor self, int[2] kernel_size, int[2] output_size, Tensor random_samples) -> (Tensor, Tensor)"
  },
  {
    "op": "fractional_max_pool2d",
    "overload": "output",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:kernel_size|output_size,view_like",
    "schema": "aten::fractional_max_pool2d.output(Tensor self, int[2] kernel_size, int[2] output_size, Tensor random_samples, *, Tensor(a!) output, Tensor(b!) indices) -> (Tensor(a!), Tensor(b!))"
  },
  {
    "op": "frexp",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::frexp.Tensor(Tensor self) -> (Tensor mantissa, Tensor exponent)"
  },
  {
    "op": "frexp",
    "overload": "Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::frexp.Tensor_out(Tensor self, *, Tensor(a!) mantissa, Tensor(b!) exponent) -> (Tensor(a!) mantissa, Tensor(b!) exponent)"
  },
  {
    "op": "frexp",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::frexp(float a) -> (float, int)"
  },
  {
    "op": "full",
    "overload": "names",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|fill_value|names|dtype|layout|pin_memory",
    "schema": "aten::full.names(int[] size, Scalar fill_value, *, str[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "full",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|fill_value|dtype|layout|pin_memory,view_like",
    "schema": "aten::full(SymInt[] size, Scalar fill_value, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "full",
    "overload": "names_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|fill_value|names,view_like",
    "schema": "aten::full.names_out(int[] size, Scalar fill_value, *, str[]? names, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "full",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|fill_value,view_like",
    "schema": "aten::full.out(SymInt[] size, Scalar fill_value, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "full_like",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:fill_value|dtype|layout|pin_memory|memory_format,view_like",
    "schema": "aten::full_like(Tensor self, Scalar fill_value, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, MemoryFormat? memory_format=None) -> Tensor"
  },
  {
    "op": "full_like",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:fill_value|memory_format,view_like",
    "schema": "aten::full_like.out(Tensor self, Scalar fill_value, *, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "gather",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::gather(Tensor self, int dim, Tensor index, *, bool sparse_grad=False) -> Tensor"
  },
  {
    "op": "gather",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::gather.out(Tensor self, int dim, Tensor index, *, bool sparse_grad=False, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "gather",
    "overload": "dimname",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::gather.dimname(Tensor self, str dim, Tensor index, *, bool sparse_grad=False) -> Tensor"
  },
  {
    "op": "gather",
    "overload": "dimname_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::gather.dimname_out(Tensor self, str dim, Tensor index, *, bool sparse_grad=False, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "gcd",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::gcd(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "gcd",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::gcd.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "gcd",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::gcd.int(int a, int b) -> int"
  },
  {
    "op": "gcd_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::gcd_(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "ge",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::ge.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "ge",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other",
    "schema": "aten::ge.Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "ge",
    "overload": "Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::ge.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "ge",
    "overload": "Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::ge.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "ge",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::ge.int(int a, int b) -> bool"
  },
  {
    "op": "ge",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::ge.float(float a, float b) -> bool"
  },
  {
    "op": "ge",
    "overload": "int_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::ge.int_float(int a, float b) -> bool"
  },
  {
    "op": "ge",
    "overload": "float_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::ge.float_int(float a, int b) -> bool"
  },
  {
    "op": "ge",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::ge(Scalar a, Scalar b) -> bool"
  },
  {
    "op": "ge",
    "overload": "str",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::ge.str(str a, str b) -> bool"
  },
  {
    "op": "ge_",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other",
    "schema": "aten::ge_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "ge_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::ge_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "gelu",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::gelu(Tensor self, *, str approximate=\"none\") -> Tensor"
  },
  {
    "op": "gelu",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::gelu.out(Tensor self, *, str approximate=\"none\", Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "gelu_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::gelu_(Tensor(a!) self, *, str approximate=\"none\") -> Tensor(a!)"
  },
  {
    "op": "gelu_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::gelu_backward(Tensor grad_output, Tensor self, *, str approximate=\"none\") -> Tensor"
  },
  {
    "op": "gelu_backward",
    "overload": "grad_input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::gelu_backward.grad_input(Tensor grad_output, Tensor self, *, str approximate=\"none\", Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "geometric",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,view_like",
    "schema": "aten::geometric(Tensor self, float p, *, Generator? generator=None) -> Tensor"
  },
  {
    "op": "geometric",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,view_like",
    "schema": "aten::geometric.out(Tensor self, float p, *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "geometric_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:generator,view_like",
    "schema": "aten::geometric_(Tensor(a!) self, float p, *, Generator? generator=None) -> Tensor(a!)"
  },
  {
    "op": "glu",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::glu(Tensor self, int dim=-1) -> Tensor"
  },
  {
    "op": "glu",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::glu.out(Tensor self, int dim=-1, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "glu_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::glu_backward(Tensor grad_output, Tensor self, int dim) -> Tensor"
  },
  {
    "op": "glu_backward",
    "overload": "grad_input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::glu_backward.grad_input(Tensor grad_output, Tensor self, int dim, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "greater",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::greater.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "greater",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::greater.Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "greater",
    "overload": "Scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::greater.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "greater",
    "overload": "Tensor_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::greater.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "greater_",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other,view_like",
    "schema": "aten::greater_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "greater_",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::greater_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "greater_equal",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::greater_equal.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "greater_equal",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::greater_equal.Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "greater_equal",
    "overload": "Scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::greater_equal.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "greater_equal",
    "overload": "Tensor_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::greater_equal.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "greater_equal_",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other,view_like",
    "schema": "aten::greater_equal_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "greater_equal_",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::greater_equal_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "grid_sampler_2d",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::grid_sampler_2d(Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners) -> Tensor"
  },
  {
    "op": "grid_sampler_2d",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::grid_sampler_2d.out(Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "grid_sampler_2d_backward",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_mask,view_like",
    "schema": "aten::grid_sampler_2d_backward(Tensor grad_output, Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners, bool[2] output_mask) -> (Tensor, Tensor)"
  },
  {
    "op": "grid_sampler_2d_backward",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_mask,view_like",
    "schema": "aten::grid_sampler_2d_backward.out(Tensor grad_output, Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners, bool[2] output_mask, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))"
  },
  {
    "op": "grid_sampler_3d",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::grid_sampler_3d(Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners) -> Tensor"
  },
  {
    "op": "grid_sampler_3d",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::grid_sampler_3d.out(Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "grid_sampler_3d_backward",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_mask,view_like",
    "schema": "aten::grid_sampler_3d_backward(Tensor grad_output, Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners, bool[2] output_mask) -> (Tensor, Tensor)"
  },
  {
    "op": "grid_sampler_3d_backward",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_mask,view_like",
    "schema": "aten::grid_sampler_3d_backward.out(Tensor grad_output, Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners, bool[2] output_mask, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))"
  },
  {
    "op": "gru",
    "overload": "input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::gru.input(Tensor input, Tensor hx, Tensor[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional, bool batch_first) -> (Tensor, Tensor)"
  },
  {
    "op": "gru",
    "overload": "data",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::gru.data(Tensor data, Tensor batch_sizes, Tensor hx, Tensor[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional) -> (Tensor, Tensor)"
  },
  {
    "op": "gt",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::gt.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "gt",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::gt.Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "gt",
    "overload": "Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::gt.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "gt",
    "overload": "Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::gt.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "gt",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::gt.int(int a, int b) -> bool"
  },
  {
    "op": "gt",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::gt.float(float a, float b) -> bool"
  },
  {
    "op": "gt",
    "overload": "int_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::gt.int_float(int a, float b) -> bool"
  },
  {
    "op": "gt",
    "overload": "float_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::gt.float_int(float a, int b) -> bool"
  },
  {
    "op": "gt",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::gt(Scalar a, Scalar b) -> bool"
  },
  {
    "op": "gt",
    "overload": "str",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::gt.str(str a, str b) -> bool"
  },
  {
    "op": "gt_",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other,view_like",
    "schema": "aten::gt_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "gt_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::gt_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "hardshrink",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::hardshrink(Tensor self, Scalar lambd=0.5) -> Tensor"
  },
  {
    "op": "hardshrink",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::hardshrink.out(Tensor self, Scalar lambd=0.5, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "hardsigmoid",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::hardsigmoid(Tensor self) -> Tensor"
  },
  {
    "op": "hardsigmoid",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::hardsigmoid.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "hardsigmoid_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::hardsigmoid_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "hardsigmoid_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::hardsigmoid_backward(Tensor grad_output, Tensor self) -> Tensor"
  },
  {
    "op": "hardsigmoid_backward",
    "overload": "grad_input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::hardsigmoid_backward.grad_input(Tensor grad_output, Tensor self, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "hardswish",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::hardswish(Tensor self) -> Tensor"
  },
  {
    "op": "hardswish",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::hardswish.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "hardswish_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::hardswish_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "hardswish_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::hardswish_backward(Tensor grad_output, Tensor self) -> Tensor"
  },
  {
    "op": "hardswish_backward",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::hardswish_backward.out(Tensor grad_output, Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "hardtanh",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::hardtanh(Tensor self, Scalar min_val=-1, Scalar max_val=1) -> Tensor"
  },
  {
    "op": "hardtanh",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::hardtanh.out(Tensor self, Scalar min_val=-1, Scalar max_val=1, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "hardtanh_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::hardtanh_(Tensor(a!) self, Scalar min_val=-1, Scalar max_val=1) -> Tensor(a!)"
  },
  {
    "op": "hardtanh_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:min_val|max_val,view_like",
    "schema": "aten::hardtanh_backward(Tensor grad_output, Tensor self, Scalar min_val, Scalar max_val) -> Tensor"
  },
  {
    "op": "hardtanh_backward",
    "overload": "grad_input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:min_val|max_val,view_like",
    "schema": "aten::hardtanh_backward.grad_input(Tensor grad_output, Tensor self, Scalar min_val, Scalar max_val, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "heaviside",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::heaviside(Tensor self, Tensor values) -> Tensor"
  },
  {
    "op": "heaviside",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::heaviside.out(Tensor self, Tensor values, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "heaviside_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::heaviside_(Tensor(a!) self, Tensor values) -> Tensor(a!)"
  },
  {
    "op": "hinge_embedding_loss",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::hinge_embedding_loss(Tensor self, Tensor target, float margin=1., int reduction=1) -> Tensor"
  },
  {
    "op": "histc",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::histc(Tensor self, int bins=100, Scalar min=0, Scalar max=0) -> Tensor"
  },
  {
    "op": "histc",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::histc.out(Tensor self, int bins=100, Scalar min=0, Scalar max=0, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "huber_loss",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::huber_loss(Tensor self, Tensor target, int reduction=1, float delta=1.) -> Tensor"
  },
  {
    "op": "huber_loss",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::huber_loss.out(Tensor self, Tensor target, int reduction=1, float delta=1., *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "huber_loss_backward",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::huber_loss_backward.out(Tensor grad_output, Tensor self, Tensor target, int reduction, float delta, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "huber_loss_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::huber_loss_backward(Tensor grad_output, Tensor self, Tensor target, int reduction, float delta) -> Tensor"
  },
  {
    "op": "hypot",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::hypot(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "hypot",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::hypot.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "hypot_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::hypot_(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "i0",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::i0(Tensor self) -> Tensor"
  },
  {
    "op": "i0",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::i0.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "i0_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::i0_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "igamma",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::igamma(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "igamma",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::igamma.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "igamma_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::igamma_(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "igammac",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::igammac(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "igammac",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::igammac.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "igammac_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::igammac_(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "im2col",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:kernel_size|dilation|padding|stride,view_like",
    "schema": "aten::im2col(Tensor self, int[2] kernel_size, int[2] dilation, int[2] padding, int[2] stride) -> Tensor"
  },
  {
    "op": "im2col",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:kernel_size|dilation|padding|stride,view_like",
    "schema": "aten::im2col.out(Tensor self, int[2] kernel_size, int[2] dilation, int[2] padding, int[2] stride, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "imag",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::imag(Tensor(a) self) -> Tensor(a)"
  },
  {
    "op": "index",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::index.Tensor(Tensor self, Tensor?[] indices) -> Tensor"
  },
  {
    "op": "index",
    "overload": "Tensor_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::index.Tensor_out(Tensor self, Tensor?[] indices, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "index",
    "overload": "Tensor_hacked_twin",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::index.Tensor_hacked_twin(Tensor self, Tensor[] indices) -> Tensor"
  },
  {
    "op": "index",
    "overload": "str",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self|substr,view_like",
    "schema": "aten::index.str(str self, str substr, int start=0, int end=-1) -> int"
  },
  {
    "op": "index",
    "overload": "list_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self,view_like",
    "schema": "aten::index.list_int(int[] self, int el) -> int"
  },
  {
    "op": "index",
    "overload": "list_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self,view_like",
    "schema": "aten::index.list_float(float[] self, float el) -> int"
  },
  {
    "op": "index",
    "overload": "list_bool",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self,view_like",
    "schema": "aten::index.list_bool(bool[] self, bool el) -> int"
  },
  {
    "op": "index",
    "overload": "list_Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::index.list_Tensor(Tensor[] self, Tensor el) -> int"
  },
  {
    "op": "index",
    "overload": "list_str",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self|el,view_like",
    "schema": "aten::index.list_str(str[] self, str el) -> int"
  },
  {
    "op": "index_add",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::index_add(Tensor self, int dim, Tensor index, Tensor source, *, Scalar alpha=1) -> Tensor"
  },
  {
    "op": "index_add",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::index_add.out(Tensor self, int dim, Tensor index, Tensor source, *, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "index_add",
    "overload": "dimname",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::index_add.dimname(Tensor self, str dim, Tensor index, Tensor source, *, Scalar alpha=1) -> Tensor"
  },
  {
    "op": "index_add_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::index_add_(Tensor(a!) self, int dim, Tensor index, Tensor source, *, Scalar alpha=1) -> Tensor(a!)"
  },
  {
    "op": "index_copy",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::index_copy(Tensor self, int dim, Tensor index, Tensor source) -> Tensor"
  },
  {
    "op": "index_copy",
    "overload": "dimname",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::index_copy.dimname(Tensor self, str dim, Tensor index, Tensor source) -> Tensor"
  },
  {
    "op": "index_copy",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::index_copy.out(Tensor self, int dim, Tensor index, Tensor source, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "index_copy_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::index_copy_(Tensor(a!) self, int dim, Tensor index, Tensor source) -> Tensor(a!)"
  },
  {
    "op": "index_copy_",
    "overload": "dimname",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:dim",
    "schema": "aten::index_copy_.dimname(Tensor(a!) self, str dim, Tensor index, Tensor source) -> Tensor(a!)"
  },
  {
    "op": "index_fill",
    "overload": "int_Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::index_fill.int_Tensor(Tensor self, int dim, Tensor index, Tensor value) -> Tensor"
  },
  {
    "op": "index_fill",
    "overload": "int_Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:value,view_like",
    "schema": "aten::index_fill.int_Scalar(Tensor self, int dim, Tensor index, Scalar value) -> Tensor"
  },
  {
    "op": "index_fill",
    "overload": "Dimname_Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim|value",
    "schema": "aten::index_fill.Dimname_Scalar(Tensor self, str dim, Tensor index, Scalar value) -> Tensor"
  },
  {
    "op": "index_fill",
    "overload": "Dimname_Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::index_fill.Dimname_Tensor(Tensor self, str dim, Tensor index, Tensor value) -> Tensor"
  },
  {
    "op": "index_fill",
    "overload": "int_Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:value,view_like",
    "schema": "aten::index_fill.int_Scalar_out(Tensor self, int dim, Tensor index, Scalar value, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "index_fill",
    "overload": "int_Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::index_fill.int_Tensor_out(Tensor self, int dim, Tensor index, Tensor value, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "index_fill_",
    "overload": "int_Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::index_fill_.int_Tensor(Tensor(a!) self, int dim, Tensor index, Tensor value) -> Tensor(a!)"
  },
  {
    "op": "index_fill_",
    "overload": "int_Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:value,view_like",
    "schema": "aten::index_fill_.int_Scalar(Tensor(a!) self, int dim, Tensor index, Scalar value) -> Tensor(a!)"
  },
  {
    "op": "index_fill_",
    "overload": "Dimname_Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:dim|value",
    "schema": "aten::index_fill_.Dimname_Scalar(Tensor(a!) self, str dim, Tensor index, Scalar value) -> Tensor(a!)"
  },
  {
    "op": "index_fill_",
    "overload": "Dimname_Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:dim,view_like",
    "schema": "aten::index_fill_.Dimname_Tensor(Tensor(a!) self, str dim, Tensor index, Tensor value) -> Tensor(a!)"
  },
  {
    "op": "index_put",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::index_put(Tensor self, Tensor?[] indices, Tensor values, bool accumulate=False) -> Tensor"
  },
  {
    "op": "index_put",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::index_put.out(Tensor self, Tensor?[] indices, Tensor values, bool accumulate=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "index_put",
    "overload": "hacked_twin",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::index_put.hacked_twin(Tensor self, Tensor[] indices, Tensor values, bool accumulate=False) -> Tensor"
  },
  {
    "op": "index_put_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::index_put_(Tensor(a!) self, Tensor?[] indices, Tensor values, bool accumulate=False) -> Tensor(a!)"
  },
  {
    "op": "index_put_",
    "overload": "hacked_twin",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::index_put_.hacked_twin(Tensor(a!) self, Tensor[] indices, Tensor values, bool accumulate=False) -> Tensor(a!)"
  },
  {
    "op": "index_reduce",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:reduce,view_like",
    "schema": "aten::index_reduce(Tensor self, int dim, Tensor index, Tensor source, str reduce, *, bool include_self=True) -> Tensor"
  },
  {
    "op": "index_reduce",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:reduce,view_like",
    "schema": "aten::index_reduce.out(Tensor self, int dim, Tensor index, Tensor source, str reduce, *, bool include_self=True, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "index_reduce_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:reduce,view_like",
    "schema": "aten::index_reduce_(Tensor(a!) self, int dim, Tensor index, Tensor source, str reduce, *, bool include_self=True) -> Tensor(a!)"
  },
  {
    "op": "index_select",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::index_select(Tensor self, int dim, Tensor index) -> Tensor"
  },
  {
    "op": "index_select",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::index_select.out(Tensor self, int dim, Tensor index, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "index_select",
    "overload": "dimname",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::index_select.dimname(Tensor self, str dim, Tensor index) -> Tensor"
  },
  {
    "op": "index_select",
    "overload": "dimname_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::index_select.dimname_out(Tensor self, str dim, Tensor index, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "is_coalesced",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::is_coalesced(Tensor self) -> bool"
  },
  {
    "op": "is_complex",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::is_complex(Tensor self) -> bool"
  },
  {
    "op": "is_contiguous",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::is_contiguous(Tensor self) -> bool"
  },
  {
    "op": "is_contiguous",
    "overload": "memory_format",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::is_contiguous.memory_format(Tensor self, MemoryFormat memory_format) -> bool"
  },
  {
    "op": "is_non_overlapping_and_dense",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::is_non_overlapping_and_dense(Tensor self) -> bool"
  },
  {
    "op": "is_pinned",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::is_pinned(Tensor self, Device? device=None) -> bool"
  },
  {
    "op": "is_same_size",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::is_same_size(Tensor self, Tensor other) -> bool"
  },
  {
    "op": "is_strides_like_format",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::is_strides_like_format(Tensor self, MemoryFormat memory_format) -> bool"
  },
  {
    "op": "isfinite",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::isfinite(Tensor self) -> Tensor"
  },
  {
    "op": "isfinite",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::isfinite.float(float a) -> bool"
  },
  {
    "op": "isfinite",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a,view_like",
    "schema": "aten::isfinite.complex(complex a) -> bool"
  },
  {
    "op": "isin",
    "overload": "Tensor_Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::isin.Tensor_Tensor(Tensor elements, Tensor test_elements, *, bool assume_unique=False, bool invert=False) -> Tensor"
  },
  {
    "op": "isin",
    "overload": "Tensor_Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::isin.Tensor_Tensor_out(Tensor elements, Tensor test_elements, *, bool assume_unique=False, bool invert=False, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "isin",
    "overload": "Tensor_Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:test_element,view_like",
    "schema": "aten::isin.Tensor_Scalar(Tensor elements, Scalar test_element, *, bool assume_unique=False, bool invert=False) -> Tensor"
  },
  {
    "op": "isin",
    "overload": "Tensor_Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:test_element,view_like",
    "schema": "aten::isin.Tensor_Scalar_out(Tensor elements, Scalar test_element, *, bool assume_unique=False, bool invert=False, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "isin",
    "overload": "Scalar_Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:element,view_like",
    "schema": "aten::isin.Scalar_Tensor(Scalar element, Tensor test_elements, *, bool assume_unique=False, bool invert=False) -> Tensor"
  },
  {
    "op": "isin",
    "overload": "Scalar_Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:element,view_like",
    "schema": "aten::isin.Scalar_Tensor_out(Scalar element, Tensor test_elements, *, bool assume_unique=False, bool invert=False, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "isinf",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::isinf(Tensor self) -> Tensor"
  },
  {
    "op": "isinf",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::isinf.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "isinf",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::isinf.float(float a) -> bool"
  },
  {
    "op": "isinf",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::isinf.complex(complex a) -> bool"
  },
  {
    "op": "isnan",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::isnan(Tensor self) -> Tensor"
  },
  {
    "op": "isnan",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::isnan.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "isnan",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::isnan.float(float a) -> bool"
  },
  {
    "op": "isnan",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::isnan.complex(complex a) -> bool"
  },
  {
    "op": "isneginf",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::isneginf(Tensor self) -> Tensor"
  },
  {
    "op": "isneginf",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::isneginf.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "isposinf",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::isposinf(Tensor self) -> Tensor"
  },
  {
    "op": "isposinf",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::isposinf.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "istft",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:hop_length|win_length|onesided|length,view_like",
    "schema": "aten::istft(Tensor self, int n_fft, int? hop_length=None, int? win_length=None, Tensor? window=None, bool center=True, bool normalized=False, bool? onesided=None, int? length=None, bool return_complex=False) -> Tensor"
  },
  {
    "op": "item",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::item(Tensor self) -> Scalar"
  },
  {
    "op": "kthvalue",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::kthvalue(Tensor self, SymInt k, int dim=-1, bool keepdim=False) -> (Tensor values, Tensor indices)"
  },
  {
    "op": "kthvalue",
    "overload": "dimname",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::kthvalue.dimname(Tensor self, SymInt k, str dim, bool keepdim=False) -> (Tensor values, Tensor indices)"
  },
  {
    "op": "kthvalue",
    "overload": "dimname_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::kthvalue.dimname_out(Tensor self, SymInt k, str dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)"
  },
  {
    "op": "kthvalue",
    "overload": "values",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::kthvalue.values(Tensor self, SymInt k, int dim=-1, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)"
  },
  {
    "op": "lcm",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::lcm(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "lcm",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::lcm.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "lcm_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::lcm_(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "le",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::le.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "le",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other",
    "schema": "aten::le.Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "le",
    "overload": "Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::le.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "le",
    "overload": "Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::le.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "le",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::le.int(int a, int b) -> bool"
  },
  {
    "op": "le",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::le.float(float a, float b) -> bool"
  },
  {
    "op": "le",
    "overload": "int_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::le.int_float(int a, float b) -> bool"
  },
  {
    "op": "le",
    "overload": "float_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::le.float_int(float a, int b) -> bool"
  },
  {
    "op": "le",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::le(Scalar a, Scalar b) -> bool"
  },
  {
    "op": "le",
    "overload": "str",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::le.str(str a, str b) -> bool"
  },
  {
    "op": "le_",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other",
    "schema": "aten::le_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "le_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::le_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "leaky_relu",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::leaky_relu(Tensor self, Scalar negative_slope=0.01) -> Tensor"
  },
  {
    "op": "leaky_relu",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::leaky_relu.out(Tensor self, Scalar negative_slope=0.01, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "leaky_relu_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::leaky_relu_(Tensor(a!) self, Scalar negative_slope=0.01) -> Tensor(a!)"
  },
  {
    "op": "leaky_relu_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:negative_slope,view_like",
    "schema": "aten::leaky_relu_backward(Tensor grad_output, Tensor self, Scalar negative_slope, bool self_is_result) -> Tensor"
  },
  {
    "op": "leaky_relu_backward",
    "overload": "grad_input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:negative_slope,view_like",
    "schema": "aten::leaky_relu_backward.grad_input(Tensor grad_output, Tensor self, Scalar negative_slope, bool self_is_result, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "lerp",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:weight",
    "schema": "aten::lerp.Scalar(Tensor self, Tensor end, Scalar weight) -> Tensor"
  },
  {
    "op": "lerp",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::lerp.Tensor(Tensor self, Tensor end, Tensor weight) -> Tensor"
  },
  {
    "op": "lerp",
    "overload": "Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:weight,view_like",
    "schema": "aten::lerp.Scalar_out(Tensor self, Tensor end, Scalar weight, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "lerp",
    "overload": "Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::lerp.Tensor_out(Tensor self, Tensor end, Tensor weight, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "lerp_",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:weight",
    "schema": "aten::lerp_.Scalar(Tensor(a!) self, Tensor end, Scalar weight) -> Tensor(a!)"
  },
  {
    "op": "lerp_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::lerp_.Tensor(Tensor(a!) self, Tensor end, Tensor weight) -> Tensor(a!)"
  },
  {
    "op": "less",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::less.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "less",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other",
    "schema": "aten::less.Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "less",
    "overload": "Scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::less.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "less",
    "overload": "Tensor_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::less.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "less_",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other",
    "schema": "aten::less_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "less_",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::less_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "less_equal",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::less_equal.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "less_equal",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other",
    "schema": "aten::less_equal.Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "less_equal",
    "overload": "Scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::less_equal.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "less_equal",
    "overload": "Tensor_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::less_equal.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "less_equal_",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other",
    "schema": "aten::less_equal_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "less_equal_",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::less_equal_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "lgamma",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::lgamma(Tensor self) -> Tensor"
  },
  {
    "op": "lgamma",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::lgamma.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "lgamma",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::lgamma.int(int a) -> float"
  },
  {
    "op": "lgamma",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::lgamma.float(float a) -> float"
  },
  {
    "op": "lgamma",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::lgamma.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "lgamma_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::lgamma_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "lift",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::lift(Tensor self) -> Tensor"
  },
  {
    "op": "lift",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::lift.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "lift_fresh",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::lift_fresh(Tensor(a) self) -> Tensor(a)"
  },
  {
    "op": "lift_fresh_copy",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::lift_fresh_copy(Tensor self) -> Tensor"
  },
  {
    "op": "lift_fresh_copy",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::lift_fresh_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "linalg_cholesky_ex",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_cholesky_ex(Tensor self, *, bool upper=False, bool check_errors=False) -> (Tensor L, Tensor info)"
  },
  {
    "op": "linalg_cholesky_ex",
    "overload": "L",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready",
    "schema": "aten::linalg_cholesky_ex.L(Tensor self, *, bool upper=False, bool check_errors=False, Tensor(a!) L, Tensor(b!) info) -> (Tensor(a!) L, Tensor(b!) info)"
  },
  {
    "op": "linalg_cross",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_cross(Tensor self, Tensor other, *, int dim=-1) -> Tensor"
  },
  {
    "op": "linalg_cross",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_cross.out(Tensor self, Tensor other, *, int dim=-1, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "linalg_eig",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_eig(Tensor self) -> (Tensor eigenvalues, Tensor eigenvectors)"
  },
  {
    "op": "linalg_eig",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_eig.out(Tensor self, *, Tensor(a!) eigenvalues, Tensor(b!) eigenvectors) -> (Tensor(a!) eigenvalues, Tensor(b!) eigenvectors)"
  },
  {
    "op": "linalg_eigvals",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_eigvals(Tensor self) -> Tensor"
  },
  {
    "op": "linalg_eigvals",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_eigvals.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "linalg_householder_product",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_householder_product(Tensor input, Tensor tau) -> Tensor"
  },
  {
    "op": "linalg_householder_product",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_householder_product.out(Tensor input, Tensor tau, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "linalg_inv_ex",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_inv_ex(Tensor A, *, bool check_errors=False) -> (Tensor inverse, Tensor info)"
  },
  {
    "op": "linalg_inv_ex",
    "overload": "inverse",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready",
    "schema": "aten::linalg_inv_ex.inverse(Tensor A, *, bool check_errors=False, Tensor(a!) inverse, Tensor(b!) info) -> (Tensor(a!) inverse, Tensor(b!) info)"
  },
  {
    "op": "linalg_ldl_factor_ex",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_ldl_factor_ex(Tensor self, *, bool hermitian=False, bool check_errors=False) -> (Tensor LD, Tensor pivots, Tensor info)"
  },
  {
    "op": "linalg_ldl_factor_ex",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_ldl_factor_ex.out(Tensor self, *, bool hermitian=False, bool check_errors=False, Tensor(a!) LD, Tensor(b!) pivots, Tensor(c!) info) -> (Tensor(a!) LD, Tensor(b!) pivots, Tensor(c!) info)"
  },
  {
    "op": "linalg_ldl_solve",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_ldl_solve(Tensor LD, Tensor pivots, Tensor B, *, bool hermitian=False) -> Tensor"
  },
  {
    "op": "linalg_ldl_solve",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_ldl_solve.out(Tensor LD, Tensor pivots, Tensor B, *, bool hermitian=False, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "linalg_lu",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_lu(Tensor A, *, bool pivot=True) -> (Tensor P, Tensor L, Tensor U)"
  },
  {
    "op": "linalg_lu",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_lu.out(Tensor A, *, bool pivot=True, Tensor(a!) P, Tensor(b!) L, Tensor(c!) U) -> (Tensor(a!) P, Tensor(b!) L, Tensor(c!) U)"
  },
  {
    "op": "linalg_lu_factor_ex",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_lu_factor_ex(Tensor A, *, bool pivot=True, bool check_errors=False) -> (Tensor LU, Tensor pivots, Tensor info)"
  },
  {
    "op": "linalg_lu_factor_ex",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_lu_factor_ex.out(Tensor A, *, bool pivot=True, bool check_errors=False, Tensor(a!) LU, Tensor(b!) pivots, Tensor(c!) info) -> (Tensor(a!) LU, Tensor(b!) pivots, Tensor(c!) info)"
  },
  {
    "op": "linalg_lu_solve",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_lu_solve(Tensor LU, Tensor pivots, Tensor B, *, bool left=True, bool adjoint=False) -> Tensor"
  },
  {
    "op": "linalg_lu_solve",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_lu_solve.out(Tensor LU, Tensor pivots, Tensor B, *, bool left=True, bool adjoint=False, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "linalg_matrix_exp",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_matrix_exp(Tensor self) -> Tensor"
  },
  {
    "op": "linalg_matrix_exp",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_matrix_exp.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "linalg_qr",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_qr(Tensor A, str mode=\"reduced\") -> (Tensor Q, Tensor R)"
  },
  {
    "op": "linalg_qr",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_qr.out(Tensor A, str mode=\"reduced\", *, Tensor(a!) Q, Tensor(b!) R) -> (Tensor(a!) Q, Tensor(b!) R)"
  },
  {
    "op": "linalg_solve_triangular",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_solve_triangular(Tensor self, Tensor B, *, bool upper, bool left=True, bool unitriangular=False) -> Tensor"
  },
  {
    "op": "linalg_solve_triangular",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linalg_solve_triangular.out(Tensor self, Tensor B, *, bool upper, bool left=True, bool unitriangular=False, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "linalg_vector_norm",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dim|dtype,view_like",
    "schema": "aten::linalg_vector_norm(Tensor self, Scalar ord=2, int[1]? dim=None, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor"
  },
  {
    "op": "linalg_vector_norm",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dim|dtype,view_like",
    "schema": "aten::linalg_vector_norm.out(Tensor self, Scalar ord=2, int[1]? dim=None, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "linear",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linear(Tensor input, Tensor weight, Tensor? bias=None) -> Tensor"
  },
  {
    "op": "linear",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linear.out(Tensor input, Tensor weight, Tensor? bias=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "linear_backward",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_mask,view_like",
    "schema": "aten::linear_backward.out(Tensor self, Tensor grad_output, Tensor weight, bool[3] output_mask, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))"
  },
  {
    "op": "linear_backward",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_mask,view_like",
    "schema": "aten::linear_backward(Tensor self, Tensor grad_output, Tensor weight, bool[3] output_mask) -> (Tensor, Tensor, Tensor)"
  },
  {
    "op": "linspace",
    "overload": "Tensor_Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype|layout|pin_memory,view_like",
    "schema": "aten::linspace.Tensor_Tensor(Tensor start, Tensor end, int steps, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "linspace",
    "overload": "Tensor_Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:end|dtype|layout|pin_memory,view_like",
    "schema": "aten::linspace.Tensor_Scalar(Tensor start, Scalar end, int steps, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "linspace",
    "overload": "Scalar_Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:start|dtype|layout|pin_memory,view_like",
    "schema": "aten::linspace.Scalar_Tensor(Scalar start, Tensor end, int steps, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "linspace",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:start|end|dtype|layout|pin_memory,view_like",
    "schema": "aten::linspace(Scalar start, Scalar end, int steps, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "linspace",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:start|end,view_like",
    "schema": "aten::linspace.out(Scalar start, Scalar end, int steps, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "linspace",
    "overload": "Tensor_Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::linspace.Tensor_Tensor_out(Tensor start, Tensor end, int steps, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "linspace",
    "overload": "Tensor_Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:end,view_like",
    "schema": "aten::linspace.Tensor_Scalar_out(Tensor start, Scalar end, int steps, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "linspace",
    "overload": "Scalar_Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:start,view_like",
    "schema": "aten::linspace.Scalar_Tensor_out(Scalar start, Tensor end, int steps, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "log",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::log(Tensor self) -> Tensor"
  },
  {
    "op": "log",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::log.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "log",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::log.int(int a) -> float"
  },
  {
    "op": "log",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::log.float(float a) -> float"
  },
  {
    "op": "log",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::log.complex(complex a) -> complex"
  },
  {
    "op": "log",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::log.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "log",
    "overload": "int_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::log.int_int(int a, int b) -> float"
  },
  {
    "op": "log",
    "overload": "float_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::log.float_float(float a, float b) -> float"
  },
  {
    "op": "log",
    "overload": "complex_complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b",
    "schema": "aten::log.complex_complex(complex a, complex b) -> complex"
  },
  {
    "op": "log",
    "overload": "int_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::log.int_float(int a, float b) -> float"
  },
  {
    "op": "log",
    "overload": "float_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::log.float_int(float a, int b) -> float"
  },
  {
    "op": "log",
    "overload": "int_complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:b,view_like",
    "schema": "aten::log.int_complex(int a, complex b) -> complex"
  },
  {
    "op": "log",
    "overload": "complex_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a,view_like",
    "schema": "aten::log.complex_int(complex a, int b) -> complex"
  },
  {
    "op": "log",
    "overload": "float_complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:b,view_like",
    "schema": "aten::log.float_complex(float a, complex b) -> complex"
  },
  {
    "op": "log",
    "overload": "complex_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a,view_like",
    "schema": "aten::log.complex_float(complex a, float b) -> complex"
  },
  {
    "op": "log",
    "overload": "Scalar_Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b",
    "schema": "aten::log.Scalar_Scalar(Scalar a, Scalar b) -> float"
  },
  {
    "op": "log10",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::log10(Tensor self) -> Tensor"
  },
  {
    "op": "log10",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::log10.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "log10",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::log10.int(int a) -> float"
  },
  {
    "op": "log10",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::log10.float(float a) -> float"
  },
  {
    "op": "log10",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::log10.complex(complex a) -> complex"
  },
  {
    "op": "log10",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::log10.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "log10_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::log10_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "log1p",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::log1p(Tensor self) -> Tensor"
  },
  {
    "op": "log1p",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::log1p.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "log1p",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::log1p.int(int a) -> float"
  },
  {
    "op": "log1p",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::log1p.float(float a) -> float"
  },
  {
    "op": "log1p",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::log1p.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "log1p_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::log1p_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "log2",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::log2(Tensor self) -> Tensor"
  },
  {
    "op": "log2",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::log2.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "log2_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::log2_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "log_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::log_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "log_normal",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,random,view_like",
    "schema": "aten::log_normal(Tensor self, float mean=1., float std=2., *, Generator? generator=None) -> Tensor"
  },
  {
    "op": "log_normal",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,random,view_like",
    "schema": "aten::log_normal.out(Tensor self, float mean=1., float std=2., *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "log_normal_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:generator,random,view_like",
    "schema": "aten::log_normal_(Tensor(a!) self, float mean=1., float std=2., *, Generator? generator=None) -> Tensor(a!)"
  },
  {
    "op": "log_sigmoid_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::log_sigmoid_backward(Tensor grad_output, Tensor self, Tensor buffer) -> Tensor"
  },
  {
    "op": "log_sigmoid_backward",
    "overload": "grad_input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::log_sigmoid_backward.grad_input(Tensor grad_output, Tensor self, Tensor buffer, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "log_sigmoid_forward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::log_sigmoid_forward(Tensor self) -> (Tensor output, Tensor buffer)"
  },
  {
    "op": "log_sigmoid_forward",
    "overload": "output",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::log_sigmoid_forward.output(Tensor self, *, Tensor(a!) output, Tensor(b!) buffer) -> (Tensor(a!), Tensor(b!))"
  },
  {
    "op": "logaddexp",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::logaddexp(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "logaddexp",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::logaddexp.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "logaddexp2",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::logaddexp2(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "logaddexp2",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::logaddexp2.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "logcumsumexp",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::logcumsumexp(Tensor self, int dim) -> Tensor"
  },
  {
    "op": "logcumsumexp",
    "overload": "dimname",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::logcumsumexp.dimname(Tensor self, str dim) -> Tensor"
  },
  {
    "op": "logcumsumexp",
    "overload": "dimname_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::logcumsumexp.dimname_out(Tensor self, str dim, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "logcumsumexp",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::logcumsumexp.out(Tensor self, int dim, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "logical_and",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::logical_and(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "logical_and",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::logical_and.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "logical_and_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::logical_and_(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "logical_not",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::logical_not(Tensor self) -> Tensor"
  },
  {
    "op": "logical_not",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::logical_not.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "logical_not_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::logical_not_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "logical_or",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::logical_or(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "logical_or",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::logical_or.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "logical_or_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::logical_or_(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "logical_xor",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::logical_xor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "logical_xor",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::logical_xor.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "logical_xor_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::logical_xor_(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "logit",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:eps,view_like",
    "schema": "aten::logit(Tensor self, float? eps=None) -> Tensor"
  },
  {
    "op": "logit",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:eps,view_like",
    "schema": "aten::logit.out(Tensor self, float? eps=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "logit_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:eps,view_like",
    "schema": "aten::logit_(Tensor(a!) self, float? eps=None) -> Tensor(a!)"
  },
  {
    "op": "logit_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:eps,view_like",
    "schema": "aten::logit_backward(Tensor grad_output, Tensor self, float? eps=None) -> Tensor"
  },
  {
    "op": "logit_backward",
    "overload": "grad_input",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:eps,view_like",
    "schema": "aten::logit_backward.grad_input(Tensor grad_output, Tensor self, float? eps=None, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "logspace",
    "overload": "Tensor_Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype|layout|pin_memory,view_like",
    "schema": "aten::logspace.Tensor_Tensor(Tensor start, Tensor end, int steps, float base=10., *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "logspace",
    "overload": "Tensor_Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:end|dtype|layout|pin_memory,view_like",
    "schema": "aten::logspace.Tensor_Scalar(Tensor start, Scalar end, int steps, float base=10., *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "logspace",
    "overload": "Scalar_Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:start|dtype|layout|pin_memory,view_like",
    "schema": "aten::logspace.Scalar_Tensor(Scalar start, Tensor end, int steps, float base=10., *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "logspace",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:start|end|dtype|layout|pin_memory,view_like",
    "schema": "aten::logspace(Scalar start, Scalar end, int steps, float base=10., *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "logspace",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:start|end,view_like",
    "schema": "aten::logspace.out(Scalar start, Scalar end, int steps, float base=10., *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "logspace",
    "overload": "Tensor_Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::logspace.Tensor_Tensor_out(Tensor start, Tensor end, int steps, float base=10., *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "logspace",
    "overload": "Tensor_Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:end,view_like",
    "schema": "aten::logspace.Tensor_Scalar_out(Tensor start, Scalar end, int steps, float base=10., *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "logspace",
    "overload": "Scalar_Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:start,view_like",
    "schema": "aten::logspace.Scalar_Tensor_out(Scalar start, Tensor end, int steps, float base=10., *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "logsumexp",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::logsumexp(Tensor self, int[1] dim, bool keepdim=False) -> Tensor"
  },
  {
    "op": "logsumexp",
    "overload": "names",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::logsumexp.names(Tensor self, str[1] dim, bool keepdim=False) -> Tensor"
  },
  {
    "op": "logsumexp",
    "overload": "names_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::logsumexp.names_out(Tensor self, str[1] dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "logsumexp",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::logsumexp.out(Tensor self, int[1] dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "lstm",
    "overload": "input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::lstm.input(Tensor input, Tensor[] hx, Tensor[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional, bool batch_first) -> (Tensor, Tensor, Tensor)"
  },
  {
    "op": "lstm",
    "overload": "data",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::lstm.data(Tensor data, Tensor batch_sizes, Tensor[] hx, Tensor[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional) -> (Tensor, Tensor, Tensor)"
  },
  {
    "op": "lt",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::lt.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "lt",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::lt.Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "lt",
    "overload": "Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::lt.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "lt",
    "overload": "Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::lt.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "lt",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::lt.int(int a, int b) -> bool"
  },
  {
    "op": "lt",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::lt.float(float a, float b) -> bool"
  },
  {
    "op": "lt",
    "overload": "int_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::lt.int_float(int a, float b) -> bool"
  },
  {
    "op": "lt",
    "overload": "float_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::lt.float_int(float a, int b) -> bool"
  },
  {
    "op": "lt",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::lt(Scalar a, Scalar b) -> bool"
  },
  {
    "op": "lt",
    "overload": "str",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::lt.str(str a, str b) -> bool"
  },
  {
    "op": "lt_",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other,view_like",
    "schema": "aten::lt_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "lt_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::lt_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "lu_unpack",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::lu_unpack(Tensor LU_data, Tensor LU_pivots, bool unpack_data=True, bool unpack_pivots=True) -> (Tensor P, Tensor L, Tensor U)"
  },
  {
    "op": "lu_unpack",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::lu_unpack.out(Tensor LU_data, Tensor LU_pivots, bool unpack_data=True, bool unpack_pivots=True, *, Tensor(a!) P, Tensor(b!) L, Tensor(c!) U) -> (Tensor(a!) P, Tensor(b!) L, Tensor(c!) U)"
  },
  {
    "op": "margin_ranking_loss",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::margin_ranking_loss(Tensor input1, Tensor input2, Tensor target, float margin=0., int reduction=1) -> Tensor"
  },
  {
    "op": "masked_fill",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:value",
    "schema": "aten::masked_fill.Scalar(Tensor self, Tensor mask, Scalar value) -> Tensor"
  },
  {
    "op": "masked_fill",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::masked_fill.Tensor(Tensor self, Tensor mask, Tensor value) -> Tensor"
  },
  {
    "op": "masked_fill",
    "overload": "Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:value,view_like",
    "schema": "aten::masked_fill.Scalar_out(Tensor self, Tensor mask, Scalar value, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "masked_fill",
    "overload": "Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::masked_fill.Tensor_out(Tensor self, Tensor mask, Tensor value, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "masked_fill_",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:value",
    "schema": "aten::masked_fill_.Scalar(Tensor(a!) self, Tensor mask, Scalar value) -> Tensor(a!)"
  },
  {
    "op": "masked_fill_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::masked_fill_.Tensor(Tensor(a!) self, Tensor mask, Tensor value) -> Tensor(a!)"
  },
  {
    "op": "masked_scatter",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::masked_scatter(Tensor self, Tensor mask, Tensor source) -> Tensor"
  },
  {
    "op": "masked_scatter",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::masked_scatter.out(Tensor self, Tensor mask, Tensor source, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "masked_scatter_",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::masked_scatter_(Tensor(a!) self, Tensor mask, Tensor source) -> Tensor(a!)"
  },
  {
    "op": "masked_scatter_backward",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:sizes,view_like",
    "schema": "aten::masked_scatter_backward(Tensor grad_output, Tensor mask, SymInt[] sizes) -> Tensor"
  },
  {
    "op": "masked_select",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::masked_select(Tensor self, Tensor mask) -> Tensor"
  },
  {
    "op": "masked_select",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::masked_select.out(Tensor self, Tensor mask, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "matmul",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::matmul(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "matmul",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::matmul.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "max",
    "overload": "other",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::max.other(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "max",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::max(Tensor self) -> Tensor"
  },
  {
    "op": "max",
    "overload": "dim",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready",
    "schema": "aten::max.dim(Tensor self, int dim, bool keepdim=False) -> (Tensor values, Tensor indices)"
  },
  {
    "op": "max",
    "overload": "dim_max",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready",
    "schema": "aten::max.dim_max(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) max, Tensor(b!) max_values) -> (Tensor(a!) values, Tensor(b!) indices)"
  },
  {
    "op": "max",
    "overload": "names_dim",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::max.names_dim(Tensor self, str dim, bool keepdim=False) -> (Tensor values, Tensor indices)"
  },
  {
    "op": "max",
    "overload": "names_dim_max",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::max.names_dim_max(Tensor self, str dim, bool keepdim=False, *, Tensor(a!) max, Tensor(b!) max_values) -> (Tensor(a!) values, Tensor(b!) indices)"
  },
  {
    "op": "max",
    "overload": "unary_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::max.unary_out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "max",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::max.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "max_pool2d_with_indices",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:kernel_size,view_like",
    "schema": "aten::max_pool2d_with_indices(Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False) -> (Tensor, Tensor)"
  },
  {
    "op": "max_pool2d_with_indices",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:kernel_size,view_like",
    "schema": "aten::max_pool2d_with_indices.out(Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False, *, Tensor(a!) out, Tensor(b!) indices) -> (Tensor(a!), Tensor(b!))"
  },
  {
    "op": "max_pool2d_with_indices_backward",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:kernel_size|stride|padding|dilation,view_like",
    "schema": "aten::max_pool2d_with_indices_backward(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride, int[2] padding, int[2] dilation, bool ceil_mode, Tensor indices) -> Tensor"
  },
  {
    "op": "max_pool2d_with_indices_backward",
    "overload": "grad_input",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:kernel_size|stride|padding|dilation,view_like",
    "schema": "aten::max_pool2d_with_indices_backward.grad_input(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride, int[2] padding, int[2] dilation, bool ceil_mode, Tensor indices, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "max_pool3d_with_indices",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:kernel_size,view_like",
    "schema": "aten::max_pool3d_with_indices(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False) -> (Tensor, Tensor)"
  },
  {
    "op": "max_pool3d_with_indices",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:kernel_size,view_like",
    "schema": "aten::max_pool3d_with_indices.out(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False, *, Tensor(a!) out, Tensor(b!) indices) -> (Tensor(a!), Tensor(b!))"
  },
  {
    "op": "max_pool3d_with_indices_backward",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:kernel_size|stride|padding|dilation,view_like",
    "schema": "aten::max_pool3d_with_indices_backward(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] stride, int[3] padding, int[3] dilation, bool ceil_mode, Tensor indices) -> Tensor"
  },
  {
    "op": "max_pool3d_with_indices_backward",
    "overload": "grad_input",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:kernel_size|stride|padding|dilation,view_like",
    "schema": "aten::max_pool3d_with_indices_backward.grad_input(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] stride, int[3] padding, int[3] dilation, bool ceil_mode, Tensor indices, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "max_unpool2d",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size,view_like",
    "schema": "aten::max_unpool2d(Tensor self, Tensor indices, SymInt[2] output_size) -> Tensor"
  },
  {
    "op": "max_unpool2d",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size,view_like",
    "schema": "aten::max_unpool2d.out(Tensor self, Tensor indices, SymInt[2] output_size, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "max_unpool3d",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|stride|padding,view_like",
    "schema": "aten::max_unpool3d(Tensor self, Tensor indices, SymInt[3] output_size, int[3] stride, int[3] padding) -> Tensor"
  },
  {
    "op": "max_unpool3d",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|stride|padding,view_like",
    "schema": "aten::max_unpool3d.out(Tensor self, Tensor indices, SymInt[3] output_size, int[3] stride, int[3] padding, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "maximum",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::maximum(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "maximum",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::maximum.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "mean",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype,view_like",
    "schema": "aten::mean(Tensor self, *, ScalarType? dtype=None) -> Tensor"
  },
  {
    "op": "mean",
    "overload": "dim",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dim|dtype",
    "schema": "aten::mean.dim(Tensor self, int[1]? dim, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor"
  },
  {
    "op": "mean",
    "overload": "names_dim",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dim|dtype",
    "schema": "aten::mean.names_dim(Tensor self, str[1] dim, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor"
  },
  {
    "op": "mean",
    "overload": "names_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dim|dtype,view_like",
    "schema": "aten::mean.names_out(Tensor self, str[1] dim, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "mean",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dim|dtype,view_like",
    "schema": "aten::mean.out(Tensor self, int[1]? dim, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "mean",
    "overload": "dtype_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype,view_like",
    "schema": "aten::mean.dtype_out(Tensor self, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "median",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::median(Tensor self) -> Tensor"
  },
  {
    "op": "median",
    "overload": "dim",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready",
    "schema": "aten::median.dim(Tensor self, int dim, bool keepdim=False) -> (Tensor values, Tensor indices)"
  },
  {
    "op": "median",
    "overload": "dim_values",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready",
    "schema": "aten::median.dim_values(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)"
  },
  {
    "op": "median",
    "overload": "names_dim",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::median.names_dim(Tensor self, str dim, bool keepdim=False) -> (Tensor values, Tensor indices)"
  },
  {
    "op": "median",
    "overload": "names_dim_values",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::median.names_dim_values(Tensor self, str dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)"
  },
  {
    "op": "median",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::median.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "meshgrid",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::meshgrid(Tensor[] tensors) -> Tensor[]"
  },
  {
    "op": "meshgrid",
    "overload": "indexing",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:indexing",
    "schema": "aten::meshgrid.indexing(Tensor[] tensors, *, str indexing) -> Tensor[]"
  },
  {
    "op": "min",
    "overload": "other",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::min.other(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "min",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::min(Tensor self) -> Tensor"
  },
  {
    "op": "min",
    "overload": "dim",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready",
    "schema": "aten::min.dim(Tensor self, int dim, bool keepdim=False) -> (Tensor values, Tensor indices)"
  },
  {
    "op": "min",
    "overload": "dim_min",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready",
    "schema": "aten::min.dim_min(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) min, Tensor(b!) min_indices) -> (Tensor(a!) values, Tensor(b!) indices)"
  },
  {
    "op": "min",
    "overload": "names_dim",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::min.names_dim(Tensor self, str dim, bool keepdim=False) -> (Tensor values, Tensor indices)"
  },
  {
    "op": "min",
    "overload": "names_dim_min",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::min.names_dim_min(Tensor self, str dim, bool keepdim=False, *, Tensor(a!) min, Tensor(b!) min_indices) -> (Tensor(a!) values, Tensor(b!) indices)"
  },
  {
    "op": "min",
    "overload": "unary_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::min.unary_out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "min",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::min.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "minimum",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::minimum(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "minimum",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::minimum.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "miopen_batch_norm",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::miopen_batch_norm(Tensor input, Tensor weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float exponential_average_factor, float epsilon) -> (Tensor, Tensor, Tensor)"
  },
  {
    "op": "miopen_batch_norm",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::miopen_batch_norm.out(Tensor input, Tensor weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float exponential_average_factor, float epsilon, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))"
  },
  {
    "op": "miopen_batch_norm_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::miopen_batch_norm_backward(Tensor input, Tensor grad_output, Tensor weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var, float epsilon) -> (Tensor, Tensor, Tensor)"
  },
  {
    "op": "miopen_batch_norm_backward",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::miopen_batch_norm_backward.out(Tensor input, Tensor grad_output, Tensor weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var, float epsilon, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))"
  },
  {
    "op": "mish",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::mish(Tensor self) -> Tensor"
  },
  {
    "op": "mish",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::mish.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "mish_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::mish_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "mish_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::mish_backward(Tensor grad_output, Tensor self) -> Tensor"
  },
  {
    "op": "mkldnn_rnn_layer",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:batch_sizes,view_like",
    "schema": "aten::mkldnn_rnn_layer(Tensor input, Tensor weight0, Tensor weight1, Tensor weight2, Tensor weight3, Tensor hx_, Tensor cx_, bool reverse, int[] batch_sizes, int mode, int hidden_size, int num_layers, bool has_biases, bool bidirectional, bool batch_first, bool train) -> (Tensor, Tensor, Tensor, Tensor)"
  },
  {
    "op": "mkldnn_rnn_layer",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:batch_sizes,view_like",
    "schema": "aten::mkldnn_rnn_layer.out(Tensor input, Tensor weight0, Tensor weight1, Tensor weight2, Tensor weight3, Tensor hx_, Tensor cx_, bool reverse, int[] batch_sizes, int mode, int hidden_size, int num_layers, bool has_biases, bool bidirectional, bool batch_first, bool train, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2, Tensor(d!) out3) -> (Tensor(a!), Tensor(b!), Tensor(c!), Tensor(d!))"
  },
  {
    "op": "mkldnn_rnn_layer_backward",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:batch_sizes,view_like",
    "schema": "aten::mkldnn_rnn_layer_backward(Tensor input, Tensor weight1, Tensor weight2, Tensor weight3, Tensor weight4, Tensor hx_, Tensor cx_tmp, Tensor output, Tensor hy_, Tensor cy_, Tensor? grad_output, Tensor? grad_hy, Tensor? grad_cy, bool reverse, int mode, int hidden_size, int num_layers, bool has_biases, bool train, bool bidirectional, int[] batch_sizes, bool batch_first, Tensor workspace) -> (Tensor, Tensor, Tensor, Tensor, Tensor, Tensor, Tensor)"
  },
  {
    "op": "mkldnn_rnn_layer_backward",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:batch_sizes,view_like",
    "schema": "aten::mkldnn_rnn_layer_backward.out(Tensor input, Tensor weight1, Tensor weight2, Tensor weight3, Tensor weight4, Tensor hx_, Tensor cx_tmp, Tensor output, Tensor hy_, Tensor cy_, Tensor? grad_output, Tensor? grad_hy, Tensor? grad_cy, bool reverse, int mode, int hidden_size, int num_layers, bool has_biases, bool train, bool bidirectional, int[] batch_sizes, bool batch_first, Tensor workspace, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2, Tensor(d!) out3, Tensor(e!) out4, Tensor(f!) out5, Tensor(g!) out6) -> (Tensor(a!), Tensor(b!), Tensor(c!), Tensor(d!), Tensor(e!), Tensor(f!), Tensor(g!))"
  },
  {
    "op": "mm",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::mm(Tensor self, Tensor mat2) -> Tensor"
  },
  {
    "op": "mm",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::mm.out(Tensor self, Tensor mat2, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "mm",
    "overload": "dtype_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_ready,view_like",
    "schema": "aten::mm.dtype_out(Tensor self, Tensor mat2, ScalarType out_dtype, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "mm",
    "overload": "dtype",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_ready,view_like",
    "schema": "aten::mm.dtype(Tensor self, Tensor mat2, ScalarType out_dtype) -> Tensor"
  },
  {
    "op": "mode",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::mode(Tensor self, int dim=-1, bool keepdim=False) -> (Tensor values, Tensor indices)"
  },
  {
    "op": "mode",
    "overload": "dimname",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::mode.dimname(Tensor self, str dim, bool keepdim=False) -> (Tensor values, Tensor indices)"
  },
  {
    "op": "mode",
    "overload": "dimname_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::mode.dimname_out(Tensor self, str dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)"
  },
  {
    "op": "mode",
    "overload": "values",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready",
    "schema": "aten::mode.values(Tensor self, int dim=-1, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)"
  },
  {
    "op": "mse_loss",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::mse_loss(Tensor self, Tensor target, int reduction=1) -> Tensor"
  },
  {
    "op": "mse_loss",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::mse_loss.out(Tensor self, Tensor target, int reduction=1, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "mse_loss_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::mse_loss_backward(Tensor grad_output, Tensor self, Tensor target, int reduction) -> Tensor"
  },
  {
    "op": "mse_loss_backward",
    "overload": "grad_input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::mse_loss_backward.grad_input(Tensor grad_output, Tensor self, Tensor target, int reduction, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "mul",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::mul.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "mul",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other",
    "schema": "aten::mul.Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "mul",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::mul.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "mul",
    "overload": "Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::mul.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "mul",
    "overload": "left_t",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:l,view_like",
    "schema": "aten::mul.left_t(t[] l, int n) -> t[]"
  },
  {
    "op": "mul",
    "overload": "right_",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:l,view_like",
    "schema": "aten::mul.right_(int n, t[] l) -> t[]"
  },
  {
    "op": "mul",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::mul.int(int a, int b) -> int"
  },
  {
    "op": "mul",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b",
    "schema": "aten::mul.complex(complex a, complex b) -> complex"
  },
  {
    "op": "mul",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::mul.float(float a, float b) -> float"
  },
  {
    "op": "mul",
    "overload": "int_complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:b,view_like",
    "schema": "aten::mul.int_complex(int a, complex b) -> complex"
  },
  {
    "op": "mul",
    "overload": "complex_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a,view_like",
    "schema": "aten::mul.complex_int(complex a, int b) -> complex"
  },
  {
    "op": "mul",
    "overload": "float_complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:b,view_like",
    "schema": "aten::mul.float_complex(float a, complex b) -> complex"
  },
  {
    "op": "mul",
    "overload": "complex_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a,view_like",
    "schema": "aten::mul.complex_float(complex a, float b) -> complex"
  },
  {
    "op": "mul",
    "overload": "int_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::mul.int_float(int a, float b) -> float"
  },
  {
    "op": "mul",
    "overload": "float_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::mul.float_int(float a, int b) -> float"
  },
  {
    "op": "mul",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::mul(Scalar a, Scalar b) -> Scalar"
  },
  {
    "op": "mul_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::mul_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "mul_",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other",
    "schema": "aten::mul_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "mul_",
    "overload": "t",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "inplace,input_missing:l,view_like",
    "schema": "aten::mul_.t(t[](a!) l, int n) -> t[](a!)"
  },
  {
    "op": "multi_margin_loss",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::multi_margin_loss(Tensor self, Tensor target, Scalar p=1, Scalar margin=1, Tensor? weight=None, int reduction=1) -> Tensor"
  },
  {
    "op": "multi_margin_loss",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::multi_margin_loss.out(Tensor self, Tensor target, Scalar p=1, Scalar margin=1, Tensor? weight=None, int reduction=1, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "multilabel_margin_loss_forward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::multilabel_margin_loss_forward(Tensor self, Tensor target, int reduction) -> (Tensor output, Tensor is_target)"
  },
  {
    "op": "multilabel_margin_loss_forward",
    "overload": "output",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::multilabel_margin_loss_forward.output(Tensor self, Tensor target, int reduction, *, Tensor(a!) output, Tensor(b!) is_target) -> (Tensor(a!), Tensor(b!))"
  },
  {
    "op": "multinomial",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,random,view_like",
    "schema": "aten::multinomial(Tensor self, SymInt num_samples, bool replacement=False, *, Generator? generator=None) -> Tensor"
  },
  {
    "op": "multinomial",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,random,view_like",
    "schema": "aten::multinomial.out(Tensor self, SymInt num_samples, bool replacement=False, *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "multiply",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::multiply.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "multiply",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::multiply.Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "multiply",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::multiply.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "multiply_",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::multiply_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "multiply_",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other,view_like",
    "schema": "aten::multiply_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "mv",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::mv(Tensor self, Tensor vec) -> Tensor"
  },
  {
    "op": "mv",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::mv.out(Tensor self, Tensor vec, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "mvlgamma",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::mvlgamma(Tensor self, int p) -> Tensor"
  },
  {
    "op": "mvlgamma",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::mvlgamma.out(Tensor self, int p, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "mvlgamma_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::mvlgamma_(Tensor(a!) self, int p) -> Tensor(a!)"
  },
  {
    "op": "nan_to_num",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:nan|posinf|neginf,view_like",
    "schema": "aten::nan_to_num(Tensor self, float? nan=None, float? posinf=None, float? neginf=None) -> Tensor"
  },
  {
    "op": "nan_to_num",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:nan|posinf|neginf,view_like",
    "schema": "aten::nan_to_num.out(Tensor self, float? nan=None, float? posinf=None, float? neginf=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "nan_to_num_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:nan|posinf|neginf,view_like",
    "schema": "aten::nan_to_num_(Tensor(a!) self, float? nan=None, float? posinf=None, float? neginf=None) -> Tensor(a!)"
  },
  {
    "op": "nanmedian",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::nanmedian(Tensor self) -> Tensor"
  },
  {
    "op": "nanmedian",
    "overload": "dim",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready",
    "schema": "aten::nanmedian.dim(Tensor self, int dim, bool keepdim=False) -> (Tensor values, Tensor indices)"
  },
  {
    "op": "nanmedian",
    "overload": "dim_values",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready",
    "schema": "aten::nanmedian.dim_values(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)"
  },
  {
    "op": "nanmedian",
    "overload": "names_dim",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::nanmedian.names_dim(Tensor self, str dim, bool keepdim=False) -> (Tensor values, Tensor indices)"
  },
  {
    "op": "nanmedian",
    "overload": "names_dim_values",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::nanmedian.names_dim_values(Tensor self, str dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)"
  },
  {
    "op": "nanmedian",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::nanmedian.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "nansum",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dim|dtype,view_like",
    "schema": "aten::nansum(Tensor self, int[1]? dim=None, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor"
  },
  {
    "op": "nansum",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dim|dtype,view_like",
    "schema": "aten::nansum.out(Tensor self, int[1]? dim=None, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "narrow",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::narrow(Tensor(a) self, int dim, SymInt start, SymInt length) -> Tensor(a)"
  },
  {
    "op": "narrow",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::narrow.Tensor(Tensor(a) self, int dim, Tensor start, SymInt length) -> Tensor(a)"
  },
  {
    "op": "narrow_copy",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::narrow_copy(Tensor self, int dim, SymInt start, SymInt length) -> Tensor"
  },
  {
    "op": "narrow_copy",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::narrow_copy.out(Tensor self, int dim, SymInt start, SymInt length, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "native_batch_norm",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::native_batch_norm(Tensor input, Tensor? weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float momentum, float eps) -> (Tensor, Tensor, Tensor)"
  },
  {
    "op": "native_batch_norm",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::native_batch_norm.out(Tensor input, Tensor? weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float momentum, float eps, *, Tensor(a!) out, Tensor(b!) save_mean, Tensor(c!) save_invstd) -> (Tensor(a!), Tensor(b!), Tensor(c!))"
  },
  {
    "op": "native_batch_norm_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_mask,view_like",
    "schema": "aten::native_batch_norm_backward(Tensor grad_out, Tensor input, Tensor? weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_invstd, bool train, float eps, bool[3] output_mask) -> (Tensor, Tensor, Tensor)"
  },
  {
    "op": "native_batch_norm_backward",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_mask,view_like",
    "schema": "aten::native_batch_norm_backward.out(Tensor grad_out, Tensor input, Tensor? weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_invstd, bool train, float eps, bool[3] output_mask, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))"
  },
  {
    "op": "native_dropout",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:train,random,view_like",
    "schema": "aten::native_dropout(Tensor input, float p, bool? train) -> (Tensor, Tensor)"
  },
  {
    "op": "native_dropout",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:train,random,view_like",
    "schema": "aten::native_dropout.out(Tensor input, float p, bool? train, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))"
  },
  {
    "op": "native_dropout_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,random,view_like",
    "schema": "aten::native_dropout_backward(Tensor grad_output, Tensor mask, float scale) -> Tensor"
  },
  {
    "op": "native_dropout_backward",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,random,view_like",
    "schema": "aten::native_dropout_backward.out(Tensor grad_output, Tensor mask, float scale, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "native_group_norm",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::native_group_norm(Tensor input, Tensor? weight, Tensor? bias, SymInt N, SymInt C, SymInt HxW, int group, float eps) -> (Tensor, Tensor, Tensor)"
  },
  {
    "op": "native_group_norm",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::native_group_norm.out(Tensor input, Tensor? weight, Tensor? bias, SymInt N, SymInt C, SymInt HxW, int group, float eps, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))"
  },
  {
    "op": "native_group_norm_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_mask,view_like",
    "schema": "aten::native_group_norm_backward(Tensor grad_out, Tensor input, Tensor mean, Tensor rstd, Tensor? weight, SymInt N, SymInt C, SymInt HxW, int group, bool[3] output_mask) -> (Tensor, Tensor, Tensor)"
  },
  {
    "op": "native_group_norm_backward",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_mask,view_like",
    "schema": "aten::native_group_norm_backward.out(Tensor grad_out, Tensor input, Tensor mean, Tensor rstd, Tensor? weight, SymInt N, SymInt C, SymInt HxW, int group, bool[3] output_mask, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))"
  },
  {
    "op": "native_layer_norm",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:normalized_shape,view_like",
    "schema": "aten::native_layer_norm(Tensor input, SymInt[] normalized_shape, Tensor? weight, Tensor? bias, float eps) -> (Tensor, Tensor, Tensor)"
  },
  {
    "op": "native_layer_norm",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:normalized_shape,view_like",
    "schema": "aten::native_layer_norm.out(Tensor input, SymInt[] normalized_shape, Tensor? weight, Tensor? bias, float eps, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))"
  },
  {
    "op": "native_layer_norm_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:normalized_shape|output_mask,view_like",
    "schema": "aten::native_layer_norm_backward(Tensor grad_out, Tensor input, SymInt[] normalized_shape, Tensor mean, Tensor rstd, Tensor? weight, Tensor? bias, bool[3] output_mask) -> (Tensor, Tensor, Tensor)"
  },
  {
    "op": "native_layer_norm_backward",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:normalized_shape|output_mask,view_like",
    "schema": "aten::native_layer_norm_backward.out(Tensor grad_out, Tensor input, SymInt[] normalized_shape, Tensor mean, Tensor rstd, Tensor? weight, Tensor? bias, bool[3] output_mask, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))"
  },
  {
    "op": "ne",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::ne.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "ne",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other",
    "schema": "aten::ne.Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "ne",
    "overload": "Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::ne.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "ne",
    "overload": "Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::ne.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "ne",
    "overload": "int_list",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::ne.int_list(int[] a, int[] b) -> bool"
  },
  {
    "op": "ne",
    "overload": "device",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready",
    "schema": "aten::ne.device(Device a, Device b) -> bool"
  },
  {
    "op": "ne",
    "overload": "bool",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready",
    "schema": "aten::ne.bool(bool a, bool b) -> bool"
  },
  {
    "op": "ne",
    "overload": "enum",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b",
    "schema": "aten::ne.enum(AnyEnumType a, AnyEnumType b) -> bool"
  },
  {
    "op": "ne",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::ne.int(int a, int b) -> bool"
  },
  {
    "op": "ne",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b",
    "schema": "aten::ne.complex(complex a, complex b) -> bool"
  },
  {
    "op": "ne",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::ne.float(float a, float b) -> bool"
  },
  {
    "op": "ne",
    "overload": "int_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::ne.int_float(int a, float b) -> bool"
  },
  {
    "op": "ne",
    "overload": "float_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::ne.float_int(float a, int b) -> bool"
  },
  {
    "op": "ne",
    "overload": "float_complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:b,view_like",
    "schema": "aten::ne.float_complex(float a, complex b) -> bool"
  },
  {
    "op": "ne",
    "overload": "complex_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a,view_like",
    "schema": "aten::ne.complex_float(complex a, float b) -> bool"
  },
  {
    "op": "ne",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::ne(Scalar a, Scalar b) -> bool"
  },
  {
    "op": "ne",
    "overload": "str",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::ne.str(str a, str b) -> bool"
  },
  {
    "op": "ne",
    "overload": "float_list",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::ne.float_list(float[] a, float[] b) -> bool"
  },
  {
    "op": "ne",
    "overload": "Tensor_list",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::ne.Tensor_list(Tensor[] a, Tensor[] b) -> bool"
  },
  {
    "op": "ne",
    "overload": "bool_list",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::ne.bool_list(bool[] a, bool[] b) -> bool"
  },
  {
    "op": "ne",
    "overload": "str_list",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::ne.str_list(str[] a, str[] b) -> bool"
  },
  {
    "op": "ne_",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other",
    "schema": "aten::ne_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "ne_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::ne_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "neg",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::neg(Tensor self) -> Tensor"
  },
  {
    "op": "neg",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::neg.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "neg",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::neg.int(int a) -> int"
  },
  {
    "op": "neg",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::neg.float(float a) -> float"
  },
  {
    "op": "neg",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::neg.complex(complex a) -> complex"
  },
  {
    "op": "neg",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::neg.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "neg_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::neg_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "negative",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::negative(Tensor self) -> Tensor"
  },
  {
    "op": "negative",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::negative.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "negative_",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::negative_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "new_empty",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|dtype|layout|pin_memory,view_like",
    "schema": "aten::new_empty(Tensor self, SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "new_empty",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size,view_like",
    "schema": "aten::new_empty.out(Tensor self, SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "new_empty_strided",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|stride|dtype|layout|pin_memory,view_like",
    "schema": "aten::new_empty_strided(Tensor self, SymInt[] size, SymInt[] stride, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "new_empty_strided",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|stride,view_like",
    "schema": "aten::new_empty_strided.out(Tensor self, SymInt[] size, SymInt[] stride, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "new_full",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|fill_value|dtype|layout|pin_memory,view_like",
    "schema": "aten::new_full(Tensor self, SymInt[] size, Scalar fill_value, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "new_full",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|fill_value,view_like",
    "schema": "aten::new_full.out(Tensor self, SymInt[] size, Scalar fill_value, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "new_ones",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|dtype|layout|pin_memory,view_like",
    "schema": "aten::new_ones(Tensor self, SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "new_ones",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size,view_like",
    "schema": "aten::new_ones.out(Tensor self, SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "new_zeros",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|dtype|layout|pin_memory,view_like",
    "schema": "aten::new_zeros(Tensor self, SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "new_zeros",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size,view_like",
    "schema": "aten::new_zeros.out(Tensor self, SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "nextafter",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::nextafter(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "nextafter",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::nextafter.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "nextafter_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::nextafter_(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "nll_loss",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::nll_loss(Tensor self, Tensor target, Tensor? weight=None, int reduction=1, SymInt ignore_index=-100) -> Tensor"
  },
  {
    "op": "nll_loss",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::nll_loss.out(Tensor self, Tensor target, Tensor? weight=None, int reduction=1, SymInt ignore_index=-100, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "nll_loss2d_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::nll_loss2d_backward(Tensor grad_output, Tensor self, Tensor target, Tensor? weight, int reduction, SymInt ignore_index, Tensor total_weight) -> Tensor"
  },
  {
    "op": "nll_loss2d_backward",
    "overload": "grad_input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::nll_loss2d_backward.grad_input(Tensor grad_output, Tensor self, Tensor target, Tensor? weight, int reduction, SymInt ignore_index, Tensor total_weight, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "nll_loss2d_forward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::nll_loss2d_forward(Tensor self, Tensor target, Tensor? weight, int reduction, SymInt ignore_index) -> (Tensor output, Tensor total_weight)"
  },
  {
    "op": "nll_loss2d_forward",
    "overload": "output",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::nll_loss2d_forward.output(Tensor self, Tensor target, Tensor? weight, int reduction, SymInt ignore_index, *, Tensor(a!) output, Tensor(b!) total_weight) -> (Tensor(a!), Tensor(b!))"
  },
  {
    "op": "nll_loss_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::nll_loss_backward(Tensor grad_output, Tensor self, Tensor target, Tensor? weight, int reduction, SymInt ignore_index, Tensor total_weight) -> Tensor"
  },
  {
    "op": "nll_loss_backward",
    "overload": "grad_input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::nll_loss_backward.grad_input(Tensor grad_output, Tensor self, Tensor target, Tensor? weight, int reduction, SymInt ignore_index, Tensor total_weight, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "nll_loss_forward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::nll_loss_forward(Tensor self, Tensor target, Tensor? weight, int reduction, SymInt ignore_index) -> (Tensor output, Tensor total_weight)"
  },
  {
    "op": "nll_loss_forward",
    "overload": "output",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::nll_loss_forward.output(Tensor self, Tensor target, Tensor? weight, int reduction, SymInt ignore_index, *, Tensor(a!) output, Tensor(b!) total_weight) -> (Tensor(a!), Tensor(b!))"
  },
  {
    "op": "nonzero",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::nonzero(Tensor self) -> Tensor"
  },
  {
    "op": "nonzero",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::nonzero.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "nonzero_numpy",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::nonzero_numpy(Tensor self) -> Tensor[]"
  },
  {
    "op": "nonzero_static",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::nonzero_static(Tensor self, *, SymInt size, int fill_value=-1) -> Tensor"
  },
  {
    "op": "nonzero_static",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::nonzero_static.out(Tensor self, *, SymInt size, int fill_value=-1, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "norm",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready",
    "schema": "aten::norm.Scalar(Tensor self, Scalar p=2) -> Tensor"
  },
  {
    "op": "norm",
    "overload": "ScalarOpt_dim",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:p|dim,view_like",
    "schema": "aten::norm.ScalarOpt_dim(Tensor self, Scalar? p, int[1] dim, bool keepdim=False) -> Tensor"
  },
  {
    "op": "norm",
    "overload": "names_ScalarOpt_dim",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:p|dim,view_like",
    "schema": "aten::norm.names_ScalarOpt_dim(Tensor self, Scalar? p, str[1] dim, bool keepdim=False) -> Tensor"
  },
  {
    "op": "norm",
    "overload": "ScalarOpt_dim_dtype",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:p|dim,view_like",
    "schema": "aten::norm.ScalarOpt_dim_dtype(Tensor self, Scalar? p, int[1] dim, bool keepdim, *, ScalarType dtype) -> Tensor"
  },
  {
    "op": "norm",
    "overload": "dtype_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:p|dim,view_like",
    "schema": "aten::norm.dtype_out(Tensor self, Scalar? p, int[1] dim, bool keepdim, *, ScalarType dtype, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "norm",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:p|dim,view_like",
    "schema": "aten::norm.out(Tensor self, Scalar? p, int[1] dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "norm",
    "overload": "ScalarOpt_dtype",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:p,view_like",
    "schema": "aten::norm.ScalarOpt_dtype(Tensor self, Scalar? p, *, ScalarType dtype) -> Tensor"
  },
  {
    "op": "norm",
    "overload": "ScalarOpt_dtype_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:p,view_like",
    "schema": "aten::norm.ScalarOpt_dtype_out(Tensor self, Scalar? p, *, ScalarType dtype, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "norm",
    "overload": "Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::norm.Scalar_out(Tensor self, Scalar p=2, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "norm",
    "overload": "names_ScalarOpt_dim_dtype",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:p|dim,view_like",
    "schema": "aten::norm.names_ScalarOpt_dim_dtype(Tensor self, Scalar? p, str[1] dim, bool keepdim, *, ScalarType dtype) -> Tensor"
  },
  {
    "op": "norm",
    "overload": "names_dtype_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:p|dim,view_like",
    "schema": "aten::norm.names_dtype_out(Tensor self, Scalar? p, str[1] dim, bool keepdim, *, ScalarType dtype, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "norm",
    "overload": "names_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:p|dim,view_like",
    "schema": "aten::norm.names_out(Tensor self, Scalar? p, str[1] dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "normal",
    "overload": "Tensor_float",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,random,view_like",
    "schema": "aten::normal.Tensor_float(Tensor mean, float std=1., *, Generator? generator=None) -> Tensor"
  },
  {
    "op": "normal",
    "overload": "Tensor_float_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,random,view_like",
    "schema": "aten::normal.Tensor_float_out(Tensor mean, float std=1., *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "normal",
    "overload": "float_Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,random,view_like",
    "schema": "aten::normal.float_Tensor_out(float mean, Tensor std, *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "normal",
    "overload": "float_Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,random,view_like",
    "schema": "aten::normal.float_Tensor(float mean, Tensor std, *, Generator? generator=None) -> Tensor"
  },
  {
    "op": "normal",
    "overload": "Tensor_Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,random,view_like",
    "schema": "aten::normal.Tensor_Tensor(Tensor mean, Tensor std, *, Generator? generator=None) -> Tensor"
  },
  {
    "op": "normal",
    "overload": "Tensor_Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,random,view_like",
    "schema": "aten::normal.Tensor_Tensor_out(Tensor mean, Tensor std, *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "normal",
    "overload": "float_float",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|generator|dtype|layout|pin_memory,random,view_like",
    "schema": "aten::normal.float_float(float mean, float std, SymInt[] size, *, Generator? generator=None, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "normal",
    "overload": "float_float_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|generator,random,view_like",
    "schema": "aten::normal.float_float_out(float mean, float std, SymInt[] size, *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "normal",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,random,view_like",
    "schema": "aten::normal.out(Tensor self, float mean=0., float std=1., *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "normal_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:generator,random,view_like",
    "schema": "aten::normal_(Tensor(a!) self, float mean=0., float std=1., *, Generator? generator=None) -> Tensor(a!)"
  },
  {
    "op": "not_equal",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::not_equal.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "not_equal",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::not_equal.Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "not_equal",
    "overload": "Scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::not_equal.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "not_equal",
    "overload": "Tensor_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::not_equal.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "not_equal_",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other,view_like",
    "schema": "aten::not_equal_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "not_equal_",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::not_equal_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "numel",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::numel(Tensor self) -> int"
  },
  {
    "op": "ones",
    "overload": "names",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|names|dtype|layout|pin_memory",
    "schema": "aten::ones.names(int[] size, *, str[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "ones",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|dtype|layout|pin_memory,view_like",
    "schema": "aten::ones(SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "ones",
    "overload": "names_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|names,view_like",
    "schema": "aten::ones.names_out(int[] size, *, str[]? names, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "ones",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size,view_like",
    "schema": "aten::ones.out(SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "ones_like",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype|layout|pin_memory|memory_format,view_like",
    "schema": "aten::ones_like(Tensor self, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, MemoryFormat? memory_format=None) -> Tensor"
  },
  {
    "op": "ones_like",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:memory_format,view_like",
    "schema": "aten::ones_like.out(Tensor self, *, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "ormqr",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::ormqr(Tensor self, Tensor input2, Tensor input3, bool left=True, bool transpose=False) -> Tensor"
  },
  {
    "op": "ormqr",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::ormqr.out(Tensor self, Tensor input2, Tensor input3, bool left=True, bool transpose=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "pad_sequence",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::pad_sequence(Tensor[] sequences, bool batch_first=False, float padding_value=0., str padding_side=\"right\") -> Tensor"
  },
  {
    "op": "pairwise_distance",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::pairwise_distance(Tensor x1, Tensor x2, float p=2., float eps=9.9999999999999995e-07, bool keepdim=False) -> Tensor"
  },
  {
    "op": "pdist",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::pdist(Tensor self, float p=2.) -> Tensor"
  },
  {
    "op": "permute",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dims,view_like",
    "schema": "aten::permute(Tensor(a) self, int[] dims) -> Tensor(a)"
  },
  {
    "op": "permute_copy",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dims,view_like",
    "schema": "aten::permute_copy(Tensor self, int[] dims) -> Tensor"
  },
  {
    "op": "permute_copy",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dims,view_like",
    "schema": "aten::permute_copy.out(Tensor self, int[] dims, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "pin_memory",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::pin_memory(Tensor(a) self, Device? device=None) -> Tensor(a)"
  },
  {
    "op": "pixel_shuffle",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::pixel_shuffle(Tensor self, int upscale_factor) -> Tensor"
  },
  {
    "op": "pixel_shuffle",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::pixel_shuffle.out(Tensor self, int upscale_factor, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "pixel_unshuffle",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::pixel_unshuffle(Tensor self, int downscale_factor) -> Tensor"
  },
  {
    "op": "pixel_unshuffle",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::pixel_unshuffle.out(Tensor self, int downscale_factor, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "poisson",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,random,view_like",
    "schema": "aten::poisson(Tensor self, Generator? generator=None) -> Tensor"
  },
  {
    "op": "poisson",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,random,view_like",
    "schema": "aten::poisson.out(Tensor self, Generator? generator=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "polar",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::polar(Tensor abs, Tensor angle) -> Tensor"
  },
  {
    "op": "polar",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::polar.out(Tensor abs, Tensor angle, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "polar",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::polar.int(int a, int b) -> complex"
  },
  {
    "op": "polar",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::polar.float(float a, float b) -> complex"
  },
  {
    "op": "polar",
    "overload": "int_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::polar.int_float(int a, float b) -> complex"
  },
  {
    "op": "polar",
    "overload": "float_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::polar.float_int(float a, int b) -> complex"
  },
  {
    "op": "polar",
    "overload": "Scalar_Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b",
    "schema": "aten::polar.Scalar_Scalar(Scalar a, Scalar b) -> Scalar"
  },
  {
    "op": "polygamma",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::polygamma(int n, Tensor self) -> Tensor"
  },
  {
    "op": "polygamma",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::polygamma.out(int n, Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "positive",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::positive(Tensor(a) self) -> Tensor(a)"
  },
  {
    "op": "pow",
    "overload": "Tensor_Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::pow.Tensor_Tensor(Tensor self, Tensor exponent) -> Tensor"
  },
  {
    "op": "pow",
    "overload": "Tensor_Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:exponent,view_like",
    "schema": "aten::pow.Tensor_Scalar(Tensor self, Scalar exponent) -> Tensor"
  },
  {
    "op": "pow",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self",
    "schema": "aten::pow.Scalar(Scalar self, Tensor exponent) -> Tensor"
  },
  {
    "op": "pow",
    "overload": "Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self,view_like",
    "schema": "aten::pow.Scalar_out(Scalar self, Tensor exponent, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "pow",
    "overload": "Tensor_Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:exponent,view_like",
    "schema": "aten::pow.Tensor_Scalar_out(Tensor self, Scalar exponent, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "pow",
    "overload": "Tensor_Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::pow.Tensor_Tensor_out(Tensor self, Tensor exponent, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "pow",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::pow.int(int a, int b) -> float"
  },
  {
    "op": "pow",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b",
    "schema": "aten::pow.complex(complex a, complex b) -> complex"
  },
  {
    "op": "pow",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::pow.float(float a, float b) -> float"
  },
  {
    "op": "pow",
    "overload": "int_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::pow.int_float(int a, float b) -> float"
  },
  {
    "op": "pow",
    "overload": "float_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::pow.float_int(float a, int b) -> float"
  },
  {
    "op": "pow",
    "overload": "float_complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:b,view_like",
    "schema": "aten::pow.float_complex(float a, complex b) -> complex"
  },
  {
    "op": "pow",
    "overload": "complex_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a,view_like",
    "schema": "aten::pow.complex_float(complex a, float b) -> complex"
  },
  {
    "op": "pow",
    "overload": "Scalar_Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b",
    "schema": "aten::pow.Scalar_Scalar(Scalar a, Scalar b) -> float"
  },
  {
    "op": "pow",
    "overload": "int_to_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::pow.int_to_int(int a, int b) -> int"
  },
  {
    "op": "pow_",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:exponent",
    "schema": "aten::pow_.Scalar(Tensor(a!) self, Scalar exponent) -> Tensor(a!)"
  },
  {
    "op": "pow_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::pow_.Tensor(Tensor(a!) self, Tensor exponent) -> Tensor(a!)"
  },
  {
    "op": "prelu",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::prelu(Tensor self, Tensor weight) -> Tensor"
  },
  {
    "op": "prod",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype,view_like",
    "schema": "aten::prod(Tensor self, *, ScalarType? dtype=None) -> Tensor"
  },
  {
    "op": "prod",
    "overload": "dim_int",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype,view_like",
    "schema": "aten::prod.dim_int(Tensor self, int dim, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor"
  },
  {
    "op": "prod",
    "overload": "dim_Dimname",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dim|dtype",
    "schema": "aten::prod.dim_Dimname(Tensor self, str dim, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor"
  },
  {
    "op": "prod",
    "overload": "Dimname_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dim|dtype,view_like",
    "schema": "aten::prod.Dimname_out(Tensor self, str dim, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "prod",
    "overload": "int_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype,view_like",
    "schema": "aten::prod.int_out(Tensor self, int dim, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "prod",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype,view_like",
    "schema": "aten::prod.out(Tensor self, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "quantized_gru",
    "overload": "input",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:params,quantized,view_like",
    "schema": "aten::quantized_gru.input(Tensor input, Tensor hx, __torch__.torch.classes.rnn.CellParamsBase[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional, bool batch_first) -> (Tensor, Tensor)"
  },
  {
    "op": "quantized_gru",
    "overload": "data",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:params,quantized,view_like",
    "schema": "aten::quantized_gru.data(Tensor data, Tensor batch_sizes, Tensor hx, __torch__.torch.classes.rnn.CellParamsBase[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional) -> (Tensor, Tensor)"
  },
  {
    "op": "quantized_gru",
    "overload": "input_legacy",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,quantized,view_like",
    "schema": "aten::quantized_gru.input_legacy(Tensor input, Tensor hx, Tensor[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional, bool batch_first) -> (Tensor, Tensor)"
  },
  {
    "op": "quantized_gru",
    "overload": "data_legacy",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,quantized,view_like",
    "schema": "aten::quantized_gru.data_legacy(Tensor data, Tensor batch_sizes, Tensor hx, Tensor[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional) -> (Tensor, Tensor)"
  },
  {
    "op": "quantized_lstm",
    "overload": "input",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:params|dtype,quantized,view_like",
    "schema": "aten::quantized_lstm.input(Tensor input, Tensor[] hx, __torch__.torch.classes.rnn.CellParamsBase[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional, bool batch_first, *, ScalarType? dtype=None, bool use_dynamic=False) -> (Tensor, Tensor, Tensor)"
  },
  {
    "op": "quantized_lstm",
    "overload": "data",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:params|dtype,quantized,view_like",
    "schema": "aten::quantized_lstm.data(Tensor data, Tensor batch_sizes, Tensor[] hx, __torch__.torch.classes.rnn.CellParamsBase[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional, *, ScalarType? dtype=None, bool use_dynamic=False) -> (Tensor, Tensor, Tensor)"
  },
  {
    "op": "quantized_lstm",
    "overload": "input_legacy",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype,quantized,view_like",
    "schema": "aten::quantized_lstm.input_legacy(Tensor input, Tensor[] hx, Tensor[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional, bool batch_first, *, ScalarType? dtype=None, bool use_dynamic=False) -> (Tensor, Tensor, Tensor)"
  },
  {
    "op": "quantized_lstm",
    "overload": "data_legacy",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype,quantized,view_like",
    "schema": "aten::quantized_lstm.data_legacy(Tensor data, Tensor batch_sizes, Tensor[] hx, Tensor[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional, *, ScalarType? dtype=None, bool use_dynamic=False) -> (Tensor, Tensor, Tensor)"
  },
  {
    "op": "rad2deg",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::rad2deg(Tensor self) -> Tensor"
  },
  {
    "op": "rad2deg",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::rad2deg.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "rad2deg_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::rad2deg_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "rand",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|dtype|layout|pin_memory,random,view_like",
    "schema": "aten::rand(SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "rand",
    "overload": "generator",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|generator|dtype|layout|pin_memory,random,view_like",
    "schema": "aten::rand.generator(SymInt[] size, *, Generator? generator, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "rand",
    "overload": "names",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|names|dtype|layout|pin_memory,random",
    "schema": "aten::rand.names(SymInt[] size, *, str[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "rand",
    "overload": "generator_with_names",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|generator|names|dtype|layout|pin_memory,random,view_like",
    "schema": "aten::rand.generator_with_names(SymInt[] size, *, Generator? generator, str[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "rand",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size,random,view_like",
    "schema": "aten::rand.out(SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "rand",
    "overload": "generator_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|generator,random,view_like",
    "schema": "aten::rand.generator_out(SymInt[] size, *, Generator? generator, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "rand",
    "overload": "names_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|names,random,view_like",
    "schema": "aten::rand.names_out(SymInt[] size, *, str[]? names, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "rand",
    "overload": "generator_with_names_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|generator|names,random,view_like",
    "schema": "aten::rand.generator_with_names_out(SymInt[] size, *, Generator? generator, str[]? names, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "rand_like",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype|layout|pin_memory|memory_format,random,view_like",
    "schema": "aten::rand_like(Tensor self, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, MemoryFormat? memory_format=None) -> Tensor"
  },
  {
    "op": "rand_like",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:memory_format,random,view_like",
    "schema": "aten::rand_like.out(Tensor self, *, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "randint",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|layout|pin_memory,random,view_like",
    "schema": "aten::randint(SymInt high, SymInt[] size, *, ScalarType? dtype=4, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "randint",
    "overload": "generator",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|generator|layout|pin_memory,random,view_like",
    "schema": "aten::randint.generator(SymInt high, SymInt[] size, *, Generator? generator, ScalarType? dtype=4, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "randint",
    "overload": "low",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|layout|pin_memory,random,view_like",
    "schema": "aten::randint.low(SymInt low, SymInt high, SymInt[] size, *, ScalarType? dtype=4, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "randint",
    "overload": "low_generator",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|generator|layout|pin_memory,random,view_like",
    "schema": "aten::randint.low_generator(SymInt low, SymInt high, SymInt[] size, *, Generator? generator, ScalarType? dtype=4, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "randint",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size,random,view_like",
    "schema": "aten::randint.out(SymInt high, SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "randint",
    "overload": "generator_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|generator,random,view_like",
    "schema": "aten::randint.generator_out(SymInt high, SymInt[] size, *, Generator? generator, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "randint",
    "overload": "low_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size,random,view_like",
    "schema": "aten::randint.low_out(SymInt low, SymInt high, SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "randint",
    "overload": "low_generator_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|generator,random,view_like",
    "schema": "aten::randint.low_generator_out(SymInt low, SymInt high, SymInt[] size, *, Generator? generator, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "randint_like",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype|layout|pin_memory|memory_format,random,view_like",
    "schema": "aten::randint_like(Tensor self, SymInt high, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, MemoryFormat? memory_format=None) -> Tensor"
  },
  {
    "op": "randint_like",
    "overload": "low_dtype",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype|layout|pin_memory|memory_format,random,view_like",
    "schema": "aten::randint_like.low_dtype(Tensor self, SymInt low, SymInt high, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, MemoryFormat? memory_format=None) -> Tensor"
  },
  {
    "op": "randint_like",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:memory_format,random,view_like",
    "schema": "aten::randint_like.out(Tensor self, SymInt high, *, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "randint_like",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype|layout|pin_memory|memory_format,random,view_like",
    "schema": "aten::randint_like.Tensor(Tensor self, Tensor high, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, MemoryFormat? memory_format=None) -> Tensor"
  },
  {
    "op": "randint_like",
    "overload": "Tensor_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:memory_format,random,view_like",
    "schema": "aten::randint_like.Tensor_out(Tensor self, Tensor high, *, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "randint_like",
    "overload": "low_dtype_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:memory_format,random,view_like",
    "schema": "aten::randint_like.low_dtype_out(Tensor self, SymInt low, SymInt high, *, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "randn",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|dtype|layout|pin_memory,random,view_like",
    "schema": "aten::randn(SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "randn",
    "overload": "generator",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|generator|dtype|layout|pin_memory,random,view_like",
    "schema": "aten::randn.generator(SymInt[] size, *, Generator? generator, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "randn",
    "overload": "names",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|names|dtype|layout|pin_memory,random",
    "schema": "aten::randn.names(SymInt[] size, *, str[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "randn",
    "overload": "generator_with_names",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|generator|names|dtype|layout|pin_memory,random,view_like",
    "schema": "aten::randn.generator_with_names(SymInt[] size, *, Generator? generator, str[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "randn",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size,random,view_like",
    "schema": "aten::randn.out(SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "randn",
    "overload": "generator_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|generator,random,view_like",
    "schema": "aten::randn.generator_out(SymInt[] size, *, Generator? generator, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "randn",
    "overload": "names_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|names,random,view_like",
    "schema": "aten::randn.names_out(SymInt[] size, *, str[]? names, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "randn",
    "overload": "generator_with_names_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|generator|names,random,view_like",
    "schema": "aten::randn.generator_with_names_out(SymInt[] size, *, Generator? generator, str[]? names, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "randn_like",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype|layout|pin_memory|memory_format,random,view_like",
    "schema": "aten::randn_like(Tensor self, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, MemoryFormat? memory_format=None) -> Tensor"
  },
  {
    "op": "randn_like",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:memory_format,random,view_like",
    "schema": "aten::randn_like.out(Tensor self, *, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "randperm",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:layout|pin_memory,random,view_like",
    "schema": "aten::randperm(SymInt n, *, ScalarType? dtype=4, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "randperm",
    "overload": "generator",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:generator|layout|pin_memory,random,view_like",
    "schema": "aten::randperm.generator(SymInt n, *, Generator? generator, ScalarType? dtype=4, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "randperm",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,random,view_like",
    "schema": "aten::randperm.out(SymInt n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "randperm",
    "overload": "generator_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,random,view_like",
    "schema": "aten::randperm.generator_out(SymInt n, *, Generator? generator, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "real",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::real(Tensor(a) self) -> Tensor(a)"
  },
  {
    "op": "reciprocal",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::reciprocal(Tensor self) -> Tensor"
  },
  {
    "op": "reciprocal",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::reciprocal.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "reciprocal_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::reciprocal_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "reflection_pad1d",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::reflection_pad1d(Tensor self, SymInt[2] padding) -> Tensor"
  },
  {
    "op": "reflection_pad1d",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::reflection_pad1d.out(Tensor self, SymInt[2] padding, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "reflection_pad1d_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::reflection_pad1d_backward(Tensor grad_output, Tensor self, SymInt[2] padding) -> Tensor"
  },
  {
    "op": "reflection_pad1d_backward",
    "overload": "grad_input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::reflection_pad1d_backward.grad_input(Tensor grad_output, Tensor self, SymInt[2] padding, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "reflection_pad2d",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::reflection_pad2d(Tensor self, SymInt[4] padding) -> Tensor"
  },
  {
    "op": "reflection_pad2d",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::reflection_pad2d.out(Tensor self, SymInt[4] padding, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "reflection_pad2d_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::reflection_pad2d_backward(Tensor grad_output, Tensor self, SymInt[4] padding) -> Tensor"
  },
  {
    "op": "reflection_pad2d_backward",
    "overload": "grad_input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::reflection_pad2d_backward.grad_input(Tensor grad_output, Tensor self, SymInt[4] padding, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "reflection_pad3d",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::reflection_pad3d(Tensor self, SymInt[6] padding) -> Tensor"
  },
  {
    "op": "reflection_pad3d",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::reflection_pad3d.out(Tensor self, SymInt[6] padding, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "reflection_pad3d_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::reflection_pad3d_backward(Tensor grad_output, Tensor self, SymInt[6] padding) -> Tensor"
  },
  {
    "op": "reflection_pad3d_backward",
    "overload": "grad_input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::reflection_pad3d_backward.grad_input(Tensor grad_output, Tensor self, SymInt[6] padding, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "relu",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::relu(Tensor self) -> Tensor"
  },
  {
    "op": "relu",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::relu.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "relu6",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::relu6(Tensor self) -> Tensor"
  },
  {
    "op": "relu_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::relu_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "remainder",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::remainder.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "remainder",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other",
    "schema": "aten::remainder.Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "remainder",
    "overload": "Scalar_Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self,view_like",
    "schema": "aten::remainder.Scalar_Tensor(Scalar self, Tensor other) -> Tensor"
  },
  {
    "op": "remainder",
    "overload": "Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::remainder.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "remainder",
    "overload": "Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::remainder.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "remainder",
    "overload": "Scalar_Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self,view_like",
    "schema": "aten::remainder.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "remainder",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::remainder.int(int a, int b) -> int"
  },
  {
    "op": "remainder",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::remainder.float(float a, float b) -> float"
  },
  {
    "op": "remainder",
    "overload": "int_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::remainder.int_float(int a, float b) -> float"
  },
  {
    "op": "remainder",
    "overload": "float_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::remainder.float_int(float a, int b) -> float"
  },
  {
    "op": "remainder",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::remainder(Scalar a, Scalar b) -> Scalar"
  },
  {
    "op": "remainder_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::remainder_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "remainder_",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other",
    "schema": "aten::remainder_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "renorm",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:p|maxnorm,view_like",
    "schema": "aten::renorm(Tensor self, Scalar p, int dim, Scalar maxnorm) -> Tensor"
  },
  {
    "op": "renorm",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:p|maxnorm,view_like",
    "schema": "aten::renorm.out(Tensor self, Scalar p, int dim, Scalar maxnorm, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "renorm_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:p|maxnorm,view_like",
    "schema": "aten::renorm_(Tensor(a!) self, Scalar p, int dim, Scalar maxnorm) -> Tensor(a!)"
  },
  {
    "op": "repeat",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:repeats,view_like",
    "schema": "aten::repeat(Tensor self, SymInt[] repeats) -> Tensor"
  },
  {
    "op": "repeat",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:repeats,view_like",
    "schema": "aten::repeat.out(Tensor self, SymInt[] repeats, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "repeat_interleave",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size,view_like",
    "schema": "aten::repeat_interleave.Tensor(Tensor repeats, *, SymInt? output_size=None) -> Tensor"
  },
  {
    "op": "repeat_interleave",
    "overload": "self_Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim|output_size,view_like",
    "schema": "aten::repeat_interleave.self_Tensor(Tensor self, Tensor repeats, int? dim=None, *, SymInt? output_size=None) -> Tensor"
  },
  {
    "op": "repeat_interleave",
    "overload": "self_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim|output_size,view_like",
    "schema": "aten::repeat_interleave.self_int(Tensor self, SymInt repeats, int? dim=None, *, SymInt? output_size=None) -> Tensor"
  },
  {
    "op": "repeat_interleave",
    "overload": "Tensor_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size,view_like",
    "schema": "aten::repeat_interleave.Tensor_out(Tensor repeats, *, SymInt? output_size=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "replication_pad1d",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::replication_pad1d(Tensor self, SymInt[2] padding) -> Tensor"
  },
  {
    "op": "replication_pad1d",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::replication_pad1d.out(Tensor self, SymInt[2] padding, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "replication_pad1d_backward",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::replication_pad1d_backward(Tensor grad_output, Tensor self, SymInt[2] padding) -> Tensor"
  },
  {
    "op": "replication_pad1d_backward",
    "overload": "grad_input",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::replication_pad1d_backward.grad_input(Tensor grad_output, Tensor self, SymInt[2] padding, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "replication_pad2d",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::replication_pad2d(Tensor self, SymInt[4] padding) -> Tensor"
  },
  {
    "op": "replication_pad2d",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::replication_pad2d.out(Tensor self, SymInt[4] padding, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "replication_pad2d_backward",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::replication_pad2d_backward(Tensor grad_output, Tensor self, SymInt[4] padding) -> Tensor"
  },
  {
    "op": "replication_pad2d_backward",
    "overload": "grad_input",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::replication_pad2d_backward.grad_input(Tensor grad_output, Tensor self, SymInt[4] padding, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "replication_pad3d",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::replication_pad3d(Tensor self, SymInt[6] padding) -> Tensor"
  },
  {
    "op": "replication_pad3d",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::replication_pad3d.out(Tensor self, SymInt[6] padding, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "replication_pad3d_backward",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::replication_pad3d_backward(Tensor grad_output, Tensor self, SymInt[6] padding) -> Tensor"
  },
  {
    "op": "replication_pad3d_backward",
    "overload": "grad_input",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:padding,view_like",
    "schema": "aten::replication_pad3d_backward.grad_input(Tensor grad_output, Tensor self, SymInt[6] padding, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "reshape",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:shape,view_like",
    "schema": "aten::reshape(Tensor(a) self, SymInt[] shape) -> Tensor(a)"
  },
  {
    "op": "resize",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|memory_format,view_like",
    "schema": "aten::resize(Tensor self, SymInt[] size, *, MemoryFormat? memory_format=None) -> Tensor"
  },
  {
    "op": "resize",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|memory_format,view_like",
    "schema": "aten::resize.out(Tensor self, SymInt[] size, *, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "resize_as",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:memory_format,view_like",
    "schema": "aten::resize_as(Tensor self, Tensor the_template, *, MemoryFormat? memory_format=None) -> Tensor"
  },
  {
    "op": "resize_as",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:memory_format,view_like",
    "schema": "aten::resize_as.out(Tensor self, Tensor the_template, *, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "resize_as_",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:memory_format,view_like",
    "schema": "aten::resize_as_(Tensor(a!) self, Tensor the_template, *, MemoryFormat? memory_format=None) -> Tensor(a!)"
  },
  {
    "op": "rnn_relu",
    "overload": "input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::rnn_relu.input(Tensor input, Tensor hx, Tensor[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional, bool batch_first) -> (Tensor, Tensor)"
  },
  {
    "op": "rnn_relu",
    "overload": "data",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::rnn_relu.data(Tensor data, Tensor batch_sizes, Tensor hx, Tensor[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional) -> (Tensor, Tensor)"
  },
  {
    "op": "rnn_tanh",
    "overload": "input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::rnn_tanh.input(Tensor input, Tensor hx, Tensor[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional, bool batch_first) -> (Tensor, Tensor)"
  },
  {
    "op": "rnn_tanh",
    "overload": "data",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::rnn_tanh.data(Tensor data, Tensor batch_sizes, Tensor hx, Tensor[] params, bool has_biases, int num_layers, float dropout, bool train, bool bidirectional) -> (Tensor, Tensor)"
  },
  {
    "op": "roll",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:shifts,view_like",
    "schema": "aten::roll(Tensor self, SymInt[1] shifts, int[1] dims=[]) -> Tensor"
  },
  {
    "op": "roll",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:shifts,view_like",
    "schema": "aten::roll.out(Tensor self, SymInt[1] shifts, int[1] dims=[], *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "rot90",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::rot90(Tensor self, int k=1, int[] dims=[0, 1]) -> Tensor"
  },
  {
    "op": "rot90",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::rot90.out(Tensor self, int k=1, int[] dims=[0, 1], *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "round",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::round(Tensor self) -> Tensor"
  },
  {
    "op": "round",
    "overload": "decimals",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready",
    "schema": "aten::round.decimals(Tensor self, *, int decimals) -> Tensor"
  },
  {
    "op": "round",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::round.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "round",
    "overload": "decimals_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::round.decimals_out(Tensor self, *, int decimals, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "round",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::round.int(int a) -> float"
  },
  {
    "op": "round",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::round.float(float a) -> float"
  },
  {
    "op": "round",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::round.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "round_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::round_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "round_",
    "overload": "decimals",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready",
    "schema": "aten::round_.decimals(Tensor(a!) self, *, int decimals) -> Tensor(a!)"
  },
  {
    "op": "rrelu_with_noise",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,random,view_like",
    "schema": "aten::rrelu_with_noise(Tensor self, Tensor(b!) noise, Scalar lower=0.125, Scalar upper=0.33333333333333331, bool training=False, Generator? generator=None) -> Tensor"
  },
  {
    "op": "rrelu_with_noise",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,random,view_like",
    "schema": "aten::rrelu_with_noise.out(Tensor self, Tensor(b!) noise, Scalar lower=0.125, Scalar upper=0.33333333333333331, bool training=False, Generator? generator=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "rrelu_with_noise_",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:generator,random,view_like",
    "schema": "aten::rrelu_with_noise_(Tensor(a!) self, Tensor(b!) noise, Scalar lower=0.125, Scalar upper=0.33333333333333331, bool training=False, Generator? generator=None) -> Tensor(a!)"
  },
  {
    "op": "rrelu_with_noise_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:lower|upper,random,view_like",
    "schema": "aten::rrelu_with_noise_backward(Tensor grad_output, Tensor self, Tensor noise, Scalar lower, Scalar upper, bool training, bool self_is_result) -> Tensor"
  },
  {
    "op": "rrelu_with_noise_backward",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:lower|upper,random,view_like",
    "schema": "aten::rrelu_with_noise_backward.out(Tensor grad_output, Tensor self, Tensor noise, Scalar lower, Scalar upper, bool training, bool self_is_result, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "rrelu_with_noise_functional",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,random,view_like",
    "schema": "aten::rrelu_with_noise_functional(Tensor self, Tensor noise, Scalar lower=0.125, Scalar upper=0.33333333333333331, bool training=False, Generator? generator=None) -> (Tensor, Tensor noise_out)"
  },
  {
    "op": "rsqrt",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::rsqrt(Tensor self) -> Tensor"
  },
  {
    "op": "rsqrt",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::rsqrt.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "rsqrt_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::rsqrt_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "rsub",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::rsub.Tensor(Tensor self, Tensor other, *, Scalar alpha=1) -> Tensor"
  },
  {
    "op": "rsub",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other",
    "schema": "aten::rsub.Scalar(Tensor self, Scalar other, Scalar alpha=1) -> Tensor"
  },
  {
    "op": "rsub",
    "overload": "Tensor_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::rsub.Tensor_out(Tensor self, Tensor other, *, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "rsub",
    "overload": "Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::rsub.Scalar_out(Tensor self, Scalar other, Scalar alpha=1, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "scalar_tensor",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:s|dtype|layout|pin_memory,view_like",
    "schema": "aten::scalar_tensor(Scalar s, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "scalar_tensor",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:s,view_like",
    "schema": "aten::scalar_tensor.out(Scalar s, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "scatter",
    "overload": "value",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:value,view_like",
    "schema": "aten::scatter.value(Tensor self, int dim, Tensor index, Scalar value) -> Tensor"
  },
  {
    "op": "scatter",
    "overload": "src",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::scatter.src(Tensor self, int dim, Tensor index, Tensor src) -> Tensor"
  },
  {
    "op": "scatter",
    "overload": "reduce",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:reduce,view_like",
    "schema": "aten::scatter.reduce(Tensor self, int dim, Tensor index, Tensor src, *, str reduce) -> Tensor"
  },
  {
    "op": "scatter",
    "overload": "value_reduce",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:value|reduce,view_like",
    "schema": "aten::scatter.value_reduce(Tensor self, int dim, Tensor index, Scalar value, *, str reduce) -> Tensor"
  },
  {
    "op": "scatter",
    "overload": "src_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::scatter.src_out(Tensor self, int dim, Tensor index, Tensor src, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "scatter",
    "overload": "value_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:value,view_like",
    "schema": "aten::scatter.value_out(Tensor self, int dim, Tensor index, Scalar value, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "scatter",
    "overload": "reduce_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:reduce,view_like",
    "schema": "aten::scatter.reduce_out(Tensor self, int dim, Tensor index, Tensor src, *, str reduce, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "scatter",
    "overload": "value_reduce_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:value|reduce,view_like",
    "schema": "aten::scatter.value_reduce_out(Tensor self, int dim, Tensor index, Scalar value, *, str reduce, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "scatter",
    "overload": "dimname_src",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::scatter.dimname_src(Tensor self, str dim, Tensor index, Tensor src) -> Tensor"
  },
  {
    "op": "scatter",
    "overload": "dimname_value",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim|value,view_like",
    "schema": "aten::scatter.dimname_value(Tensor self, str dim, Tensor index, Scalar value) -> Tensor"
  },
  {
    "op": "scatter_",
    "overload": "src",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::scatter_.src(Tensor(a!) self, int dim, Tensor index, Tensor src) -> Tensor(a!)"
  },
  {
    "op": "scatter_",
    "overload": "value",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:value,view_like",
    "schema": "aten::scatter_.value(Tensor(a!) self, int dim, Tensor index, Scalar value) -> Tensor(a!)"
  },
  {
    "op": "scatter_",
    "overload": "reduce",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:reduce,view_like",
    "schema": "aten::scatter_.reduce(Tensor(a!) self, int dim, Tensor index, Tensor src, *, str reduce) -> Tensor(a!)"
  },
  {
    "op": "scatter_",
    "overload": "value_reduce",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:value|reduce,view_like",
    "schema": "aten::scatter_.value_reduce(Tensor(a!) self, int dim, Tensor index, Scalar value, *, str reduce) -> Tensor(a!)"
  },
  {
    "op": "scatter_add",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::scatter_add(Tensor self, int dim, Tensor index, Tensor src) -> Tensor"
  },
  {
    "op": "scatter_add",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::scatter_add.out(Tensor self, int dim, Tensor index, Tensor src, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "scatter_add",
    "overload": "dimname",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::scatter_add.dimname(Tensor self, str dim, Tensor index, Tensor src) -> Tensor"
  },
  {
    "op": "scatter_add_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::scatter_add_(Tensor(a!) self, int dim, Tensor index, Tensor src) -> Tensor(a!)"
  },
  {
    "op": "scatter_reduce",
    "overload": "two",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:reduce,view_like",
    "schema": "aten::scatter_reduce.two(Tensor self, int dim, Tensor index, Tensor src, str reduce, *, bool include_self=True) -> Tensor"
  },
  {
    "op": "scatter_reduce",
    "overload": "two_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:reduce,view_like",
    "schema": "aten::scatter_reduce.two_out(Tensor self, int dim, Tensor index, Tensor src, str reduce, *, bool include_self=True, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "scatter_reduce_",
    "overload": "two",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:reduce,view_like",
    "schema": "aten::scatter_reduce_.two(Tensor(a!) self, int dim, Tensor index, Tensor src, str reduce, *, bool include_self=True) -> Tensor(a!)"
  },
  {
    "op": "searchsorted",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:side,view_like",
    "schema": "aten::searchsorted.Tensor(Tensor sorted_sequence, Tensor self, *, bool out_int32=False, bool right=False, str? side=None, Tensor? sorter=None) -> Tensor"
  },
  {
    "op": "searchsorted",
    "overload": "Tensor_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:side,view_like",
    "schema": "aten::searchsorted.Tensor_out(Tensor sorted_sequence, Tensor self, *, bool out_int32=False, bool right=False, str? side=None, Tensor? sorter=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "searchsorted",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self|side,view_like",
    "schema": "aten::searchsorted.Scalar(Tensor sorted_sequence, Scalar self, *, bool out_int32=False, bool right=False, str? side=None, Tensor? sorter=None) -> Tensor"
  },
  {
    "op": "searchsorted",
    "overload": "Scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self|side,view_like",
    "schema": "aten::searchsorted.Scalar_out(Tensor sorted_sequence, Scalar self, *, bool out_int32=False, bool right=False, str? side=None, Tensor? sorter=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "segment_reduce",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:reduce|initial,view_like",
    "schema": "aten::segment_reduce(Tensor data, str reduce, *, Tensor? lengths=None, Tensor? indices=None, Tensor? offsets=None, int axis=0, bool unsafe=False, Scalar? initial=None) -> Tensor"
  },
  {
    "op": "segment_reduce",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:reduce|initial,view_like",
    "schema": "aten::segment_reduce.out(Tensor data, str reduce, *, Tensor? lengths=None, Tensor? indices=None, Tensor? offsets=None, int axis=0, bool unsafe=False, Scalar? initial=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "select",
    "overload": "Dimname",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::select.Dimname(Tensor(a) self, str dim, int index) -> Tensor(a)"
  },
  {
    "op": "select",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::select.int(Tensor(a) self, int dim, SymInt index) -> Tensor(a)"
  },
  {
    "op": "select",
    "overload": "t",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:list,view_like",
    "schema": "aten::select.t(t[](a) list, int idx) -> t(*)"
  },
  {
    "op": "select_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:input_sizes,view_like",
    "schema": "aten::select_backward(Tensor grad_output, SymInt[] input_sizes, int dim, SymInt index) -> Tensor"
  },
  {
    "op": "select_backward",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:input_sizes,view_like",
    "schema": "aten::select_backward.out(Tensor grad_output, SymInt[] input_sizes, int dim, SymInt index, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "select_scatter",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::select_scatter(Tensor self, Tensor src, int dim, SymInt index) -> Tensor"
  },
  {
    "op": "select_scatter",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::select_scatter.out(Tensor self, Tensor src, int dim, SymInt index, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "selu",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::selu(Tensor self) -> Tensor"
  },
  {
    "op": "selu_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::selu_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "set_",
    "overload": "source_Storage_storage_offset",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:source|size,view_like",
    "schema": "aten::set_.source_Storage_storage_offset(Tensor(a!) self, Storage source, SymInt storage_offset, SymInt[] size, SymInt[] stride=[]) -> Tensor(a!)"
  },
  {
    "op": "set_",
    "overload": "source_Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::set_.source_Tensor(Tensor(a!) self, Tensor source) -> Tensor(a!)"
  },
  {
    "op": "set_",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::set_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "set_",
    "overload": "source_Storage",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:source,view_like",
    "schema": "aten::set_.source_Storage(Tensor(a!) self, Storage source) -> Tensor(a!)"
  },
  {
    "op": "set_",
    "overload": "source_Tensor_storage_offset",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:size,view_like",
    "schema": "aten::set_.source_Tensor_storage_offset(Tensor(a!) self, Tensor source, SymInt storage_offset, SymInt[] size, SymInt[] stride=[]) -> Tensor(a!)"
  },
  {
    "op": "sgn",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sgn(Tensor self) -> Tensor"
  },
  {
    "op": "sgn",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sgn.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "sgn_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::sgn_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "sigmoid",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sigmoid(Tensor self) -> Tensor"
  },
  {
    "op": "sigmoid",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sigmoid.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "sigmoid_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::sigmoid_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "sigmoid_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sigmoid_backward(Tensor grad_output, Tensor output) -> Tensor"
  },
  {
    "op": "sigmoid_backward",
    "overload": "grad_input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sigmoid_backward.grad_input(Tensor grad_output, Tensor output, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "sign",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sign(Tensor self) -> Tensor"
  },
  {
    "op": "sign",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sign.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "sign_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::sign_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "signbit",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::signbit(Tensor self) -> Tensor"
  },
  {
    "op": "signbit",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::signbit.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "silu",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::silu(Tensor self) -> Tensor"
  },
  {
    "op": "silu",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::silu.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "silu_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::silu_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "silu_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::silu_backward(Tensor grad_output, Tensor self) -> Tensor"
  },
  {
    "op": "silu_backward",
    "overload": "grad_input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::silu_backward.grad_input(Tensor grad_output, Tensor self, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "sin",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sin(Tensor self) -> Tensor"
  },
  {
    "op": "sin",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sin.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "sin",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::sin.int(int a) -> float"
  },
  {
    "op": "sin",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::sin.float(float a) -> float"
  },
  {
    "op": "sin",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::sin.complex(complex a) -> complex"
  },
  {
    "op": "sin",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::sin.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "sin_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::sin_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "sinc",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sinc(Tensor self) -> Tensor"
  },
  {
    "op": "sinc",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sinc.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "sinc_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::sinc_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "sinh",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sinh(Tensor self) -> Tensor"
  },
  {
    "op": "sinh",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sinh.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "sinh",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::sinh.int(int a) -> float"
  },
  {
    "op": "sinh",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::sinh.float(float a) -> float"
  },
  {
    "op": "sinh",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::sinh.complex(complex a) -> complex"
  },
  {
    "op": "sinh",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a",
    "schema": "aten::sinh.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "sinh_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::sinh_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "size",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::size.int(Tensor self, int dim) -> int"
  },
  {
    "op": "size",
    "overload": "Dimname",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::size.Dimname(Tensor self, str dim) -> int"
  },
  {
    "op": "size",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::size(Tensor self) -> int[]"
  },
  {
    "op": "slice",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:start|end,view_like",
    "schema": "aten::slice.Tensor(Tensor(a) self, int dim=0, SymInt? start=None, SymInt? end=None, SymInt step=1) -> Tensor(a)"
  },
  {
    "op": "slice",
    "overload": "t",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:l|start|end,view_like",
    "schema": "aten::slice.t(t[] l, int? start=None, int? end=None, int step=1) -> t[]"
  },
  {
    "op": "slice",
    "overload": "str",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:string|start|end,view_like",
    "schema": "aten::slice.str(str string, int? start=None, int? end=None, int step=1) -> str"
  },
  {
    "op": "slice_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:input_sizes,view_like",
    "schema": "aten::slice_backward(Tensor grad_output, SymInt[] input_sizes, int dim, SymInt start, SymInt end, SymInt step) -> Tensor"
  },
  {
    "op": "slice_backward",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:input_sizes,view_like",
    "schema": "aten::slice_backward.out(Tensor grad_output, SymInt[] input_sizes, int dim, SymInt start, SymInt end, SymInt step, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "slice_scatter",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:start|end,view_like",
    "schema": "aten::slice_scatter(Tensor self, Tensor src, int dim=0, SymInt? start=None, SymInt? end=None, SymInt step=1) -> Tensor"
  },
  {
    "op": "slice_scatter",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:start|end,view_like",
    "schema": "aten::slice_scatter.out(Tensor self, Tensor src, int dim=0, SymInt? start=None, SymInt? end=None, SymInt step=1, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "smooth_l1_loss",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::smooth_l1_loss(Tensor self, Tensor target, int reduction=1, float beta=1.) -> Tensor"
  },
  {
    "op": "smooth_l1_loss",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::smooth_l1_loss.out(Tensor self, Tensor target, int reduction=1, float beta=1., *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "smooth_l1_loss_backward",
    "overload": "grad_input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::smooth_l1_loss_backward.grad_input(Tensor grad_output, Tensor self, Tensor target, int reduction, float beta, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "smooth_l1_loss_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::smooth_l1_loss_backward(Tensor grad_output, Tensor self, Tensor target, int reduction, float beta) -> Tensor"
  },
  {
    "op": "soft_margin_loss",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::soft_margin_loss(Tensor self, Tensor target, int reduction=1) -> Tensor"
  },
  {
    "op": "soft_margin_loss",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::soft_margin_loss.out(Tensor self, Tensor target, int reduction=1, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "soft_margin_loss_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::soft_margin_loss_backward(Tensor grad_output, Tensor self, Tensor target, int reduction) -> Tensor"
  },
  {
    "op": "soft_margin_loss_backward",
    "overload": "grad_input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::soft_margin_loss_backward.grad_input(Tensor grad_output, Tensor self, Tensor target, int reduction, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "softplus",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::softplus(Tensor self, Scalar beta=1, Scalar threshold=20) -> Tensor"
  },
  {
    "op": "softplus",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::softplus.out(Tensor self, Scalar beta=1, Scalar threshold=20, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "softplus_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:beta|threshold,view_like",
    "schema": "aten::softplus_backward(Tensor grad_output, Tensor self, Scalar beta, Scalar threshold) -> Tensor"
  },
  {
    "op": "softplus_backward",
    "overload": "grad_input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:beta|threshold,view_like",
    "schema": "aten::softplus_backward.grad_input(Tensor grad_output, Tensor self, Scalar beta, Scalar threshold, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "softshrink",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::softshrink(Tensor self, Scalar lambd=0.5) -> Tensor"
  },
  {
    "op": "softshrink",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::softshrink.out(Tensor self, Scalar lambd=0.5, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "sort",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sort(Tensor self, int dim=-1, bool descending=False) -> (Tensor values, Tensor indices)"
  },
  {
    "op": "sort",
    "overload": "stable",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:stable,view_like",
    "schema": "aten::sort.stable(Tensor self, *, bool? stable, int dim=-1, bool descending=False) -> (Tensor values, Tensor indices)"
  },
  {
    "op": "sort",
    "overload": "values_stable",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:stable,view_like",
    "schema": "aten::sort.values_stable(Tensor self, *, bool? stable, int dim=-1, bool descending=False, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)"
  },
  {
    "op": "sort",
    "overload": "values",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sort.values(Tensor self, int dim=-1, bool descending=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)"
  },
  {
    "op": "sort",
    "overload": "dimname",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::sort.dimname(Tensor self, str dim, bool descending=False) -> (Tensor values, Tensor indices)"
  },
  {
    "op": "sort",
    "overload": "dimname_values",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::sort.dimname_values(Tensor self, str dim, bool descending=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)"
  },
  {
    "op": "sort",
    "overload": "dimname_stable",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:stable|dim,view_like",
    "schema": "aten::sort.dimname_stable(Tensor self, *, bool? stable, str dim, bool descending=False) -> (Tensor values, Tensor indices)"
  },
  {
    "op": "sort",
    "overload": "dimname_values_stable",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:stable|dim,view_like",
    "schema": "aten::sort.dimname_values_stable(Tensor self, *, bool? stable, str dim, bool descending=False, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)"
  },
  {
    "op": "sort",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self,view_like",
    "schema": "aten::sort.int(int[](a!) self, bool reverse=False) -> ()"
  },
  {
    "op": "sort",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self,view_like",
    "schema": "aten::sort.float(float[](a!) self, bool reverse=False) -> ()"
  },
  {
    "op": "sort",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sort.Tensor(Tensor[](a!) self, bool reverse=False) -> ()"
  },
  {
    "op": "sort",
    "overload": "bool",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self,view_like",
    "schema": "aten::sort.bool(bool[](a!) self, bool reverse=False) -> ()"
  },
  {
    "op": "sort",
    "overload": "str",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self,view_like",
    "schema": "aten::sort.str(str[](a!) self, bool reverse=False) -> ()"
  },
  {
    "op": "sort",
    "overload": "any",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self,view_like",
    "schema": "aten::sort.any(t[](a!) self, bool reverse=False) -> ()"
  },
  {
    "op": "sparse_dim",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,sparse,view_like",
    "schema": "aten::sparse_dim(Tensor self) -> int"
  },
  {
    "op": "special_airy_ai",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_airy_ai(Tensor x) -> Tensor"
  },
  {
    "op": "special_airy_ai",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_airy_ai.out(Tensor x, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_bessel_j0",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_bessel_j0(Tensor self) -> Tensor"
  },
  {
    "op": "special_bessel_j0",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_bessel_j0.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_bessel_j1",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_bessel_j1(Tensor self) -> Tensor"
  },
  {
    "op": "special_bessel_j1",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_bessel_j1.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_bessel_y0",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_bessel_y0(Tensor self) -> Tensor"
  },
  {
    "op": "special_bessel_y0",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_bessel_y0.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_bessel_y1",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_bessel_y1(Tensor self) -> Tensor"
  },
  {
    "op": "special_bessel_y1",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_bessel_y1.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_chebyshev_polynomial_t",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_chebyshev_polynomial_t(Tensor x, Tensor n) -> Tensor"
  },
  {
    "op": "special_chebyshev_polynomial_t",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_chebyshev_polynomial_t.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_chebyshev_polynomial_t",
    "overload": "x_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x,view_like",
    "schema": "aten::special_chebyshev_polynomial_t.x_scalar(Scalar x, Tensor n) -> Tensor"
  },
  {
    "op": "special_chebyshev_polynomial_t",
    "overload": "x_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x,view_like",
    "schema": "aten::special_chebyshev_polynomial_t.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_chebyshev_polynomial_t",
    "overload": "n_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n,view_like",
    "schema": "aten::special_chebyshev_polynomial_t.n_scalar(Tensor x, Scalar n) -> Tensor"
  },
  {
    "op": "special_chebyshev_polynomial_t",
    "overload": "n_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n,view_like",
    "schema": "aten::special_chebyshev_polynomial_t.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_chebyshev_polynomial_u",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_chebyshev_polynomial_u(Tensor x, Tensor n) -> Tensor"
  },
  {
    "op": "special_chebyshev_polynomial_u",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_chebyshev_polynomial_u.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_chebyshev_polynomial_u",
    "overload": "x_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x",
    "schema": "aten::special_chebyshev_polynomial_u.x_scalar(Scalar x, Tensor n) -> Tensor"
  },
  {
    "op": "special_chebyshev_polynomial_u",
    "overload": "x_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x,view_like",
    "schema": "aten::special_chebyshev_polynomial_u.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_chebyshev_polynomial_u",
    "overload": "n_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n",
    "schema": "aten::special_chebyshev_polynomial_u.n_scalar(Tensor x, Scalar n) -> Tensor"
  },
  {
    "op": "special_chebyshev_polynomial_u",
    "overload": "n_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n,view_like",
    "schema": "aten::special_chebyshev_polynomial_u.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_chebyshev_polynomial_v",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_chebyshev_polynomial_v(Tensor x, Tensor n) -> Tensor"
  },
  {
    "op": "special_chebyshev_polynomial_v",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_chebyshev_polynomial_v.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_chebyshev_polynomial_v",
    "overload": "x_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x",
    "schema": "aten::special_chebyshev_polynomial_v.x_scalar(Scalar x, Tensor n) -> Tensor"
  },
  {
    "op": "special_chebyshev_polynomial_v",
    "overload": "x_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x,view_like",
    "schema": "aten::special_chebyshev_polynomial_v.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_chebyshev_polynomial_v",
    "overload": "n_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n",
    "schema": "aten::special_chebyshev_polynomial_v.n_scalar(Tensor x, Scalar n) -> Tensor"
  },
  {
    "op": "special_chebyshev_polynomial_v",
    "overload": "n_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n,view_like",
    "schema": "aten::special_chebyshev_polynomial_v.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_chebyshev_polynomial_w",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_chebyshev_polynomial_w(Tensor x, Tensor n) -> Tensor"
  },
  {
    "op": "special_chebyshev_polynomial_w",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_chebyshev_polynomial_w.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_chebyshev_polynomial_w",
    "overload": "x_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x",
    "schema": "aten::special_chebyshev_polynomial_w.x_scalar(Scalar x, Tensor n) -> Tensor"
  },
  {
    "op": "special_chebyshev_polynomial_w",
    "overload": "x_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x,view_like",
    "schema": "aten::special_chebyshev_polynomial_w.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_chebyshev_polynomial_w",
    "overload": "n_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n",
    "schema": "aten::special_chebyshev_polynomial_w.n_scalar(Tensor x, Scalar n) -> Tensor"
  },
  {
    "op": "special_chebyshev_polynomial_w",
    "overload": "n_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n,view_like",
    "schema": "aten::special_chebyshev_polynomial_w.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_entr",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_entr(Tensor self) -> Tensor"
  },
  {
    "op": "special_entr",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_entr.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_erfcx",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_erfcx(Tensor self) -> Tensor"
  },
  {
    "op": "special_erfcx",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_erfcx.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_hermite_polynomial_h",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_hermite_polynomial_h(Tensor x, Tensor n) -> Tensor"
  },
  {
    "op": "special_hermite_polynomial_h",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_hermite_polynomial_h.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_hermite_polynomial_h",
    "overload": "x_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x,view_like",
    "schema": "aten::special_hermite_polynomial_h.x_scalar(Scalar x, Tensor n) -> Tensor"
  },
  {
    "op": "special_hermite_polynomial_h",
    "overload": "x_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x,view_like",
    "schema": "aten::special_hermite_polynomial_h.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_hermite_polynomial_h",
    "overload": "n_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n,view_like",
    "schema": "aten::special_hermite_polynomial_h.n_scalar(Tensor x, Scalar n) -> Tensor"
  },
  {
    "op": "special_hermite_polynomial_h",
    "overload": "n_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n,view_like",
    "schema": "aten::special_hermite_polynomial_h.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_hermite_polynomial_he",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_hermite_polynomial_he(Tensor x, Tensor n) -> Tensor"
  },
  {
    "op": "special_hermite_polynomial_he",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_hermite_polynomial_he.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_hermite_polynomial_he",
    "overload": "x_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x,view_like",
    "schema": "aten::special_hermite_polynomial_he.x_scalar(Scalar x, Tensor n) -> Tensor"
  },
  {
    "op": "special_hermite_polynomial_he",
    "overload": "x_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x,view_like",
    "schema": "aten::special_hermite_polynomial_he.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_hermite_polynomial_he",
    "overload": "n_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n,view_like",
    "schema": "aten::special_hermite_polynomial_he.n_scalar(Tensor x, Scalar n) -> Tensor"
  },
  {
    "op": "special_hermite_polynomial_he",
    "overload": "n_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n,view_like",
    "schema": "aten::special_hermite_polynomial_he.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_i0e",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_i0e(Tensor self) -> Tensor"
  },
  {
    "op": "special_i0e",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_i0e.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_i1",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_i1(Tensor self) -> Tensor"
  },
  {
    "op": "special_i1",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_i1.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_i1e",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_i1e(Tensor self) -> Tensor"
  },
  {
    "op": "special_i1e",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_i1e.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_laguerre_polynomial_l",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_laguerre_polynomial_l(Tensor x, Tensor n) -> Tensor"
  },
  {
    "op": "special_laguerre_polynomial_l",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_laguerre_polynomial_l.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_laguerre_polynomial_l",
    "overload": "x_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x",
    "schema": "aten::special_laguerre_polynomial_l.x_scalar(Scalar x, Tensor n) -> Tensor"
  },
  {
    "op": "special_laguerre_polynomial_l",
    "overload": "x_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x,view_like",
    "schema": "aten::special_laguerre_polynomial_l.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_laguerre_polynomial_l",
    "overload": "n_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n",
    "schema": "aten::special_laguerre_polynomial_l.n_scalar(Tensor x, Scalar n) -> Tensor"
  },
  {
    "op": "special_laguerre_polynomial_l",
    "overload": "n_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n,view_like",
    "schema": "aten::special_laguerre_polynomial_l.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_legendre_polynomial_p",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_legendre_polynomial_p(Tensor x, Tensor n) -> Tensor"
  },
  {
    "op": "special_legendre_polynomial_p",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_legendre_polynomial_p.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_legendre_polynomial_p",
    "overload": "x_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x",
    "schema": "aten::special_legendre_polynomial_p.x_scalar(Scalar x, Tensor n) -> Tensor"
  },
  {
    "op": "special_legendre_polynomial_p",
    "overload": "x_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x,view_like",
    "schema": "aten::special_legendre_polynomial_p.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_legendre_polynomial_p",
    "overload": "n_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n",
    "schema": "aten::special_legendre_polynomial_p.n_scalar(Tensor x, Scalar n) -> Tensor"
  },
  {
    "op": "special_legendre_polynomial_p",
    "overload": "n_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n,view_like",
    "schema": "aten::special_legendre_polynomial_p.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_log_ndtr",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_log_ndtr(Tensor self) -> Tensor"
  },
  {
    "op": "special_log_ndtr",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_log_ndtr.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_modified_bessel_i0",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_modified_bessel_i0(Tensor self) -> Tensor"
  },
  {
    "op": "special_modified_bessel_i0",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_modified_bessel_i0.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_modified_bessel_i1",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_modified_bessel_i1(Tensor self) -> Tensor"
  },
  {
    "op": "special_modified_bessel_i1",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_modified_bessel_i1.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_modified_bessel_k0",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_modified_bessel_k0(Tensor self) -> Tensor"
  },
  {
    "op": "special_modified_bessel_k0",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_modified_bessel_k0.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_modified_bessel_k1",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_modified_bessel_k1(Tensor self) -> Tensor"
  },
  {
    "op": "special_modified_bessel_k1",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_modified_bessel_k1.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_ndtr",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_ndtr(Tensor self) -> Tensor"
  },
  {
    "op": "special_ndtr",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_ndtr.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_ndtri",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_ndtri(Tensor self) -> Tensor"
  },
  {
    "op": "special_ndtri",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_ndtri.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_scaled_modified_bessel_k0",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_scaled_modified_bessel_k0(Tensor x) -> Tensor"
  },
  {
    "op": "special_scaled_modified_bessel_k0",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_scaled_modified_bessel_k0.out(Tensor x, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_scaled_modified_bessel_k1",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_scaled_modified_bessel_k1(Tensor x) -> Tensor"
  },
  {
    "op": "special_scaled_modified_bessel_k1",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_scaled_modified_bessel_k1.out(Tensor x, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_t",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_t(Tensor x, Tensor n) -> Tensor"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_t",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_t.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_t",
    "overload": "x_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_t.x_scalar(Scalar x, Tensor n) -> Tensor"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_t",
    "overload": "x_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_t.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_t",
    "overload": "n_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_t.n_scalar(Tensor x, Scalar n) -> Tensor"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_t",
    "overload": "n_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_t.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_u",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_u(Tensor x, Tensor n) -> Tensor"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_u",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_u.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_u",
    "overload": "x_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_u.x_scalar(Scalar x, Tensor n) -> Tensor"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_u",
    "overload": "x_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_u.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_u",
    "overload": "n_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_u.n_scalar(Tensor x, Scalar n) -> Tensor"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_u",
    "overload": "n_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_u.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_v",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_v(Tensor x, Tensor n) -> Tensor"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_v",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_v.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_v",
    "overload": "x_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_v.x_scalar(Scalar x, Tensor n) -> Tensor"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_v",
    "overload": "x_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_v.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_v",
    "overload": "n_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_v.n_scalar(Tensor x, Scalar n) -> Tensor"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_v",
    "overload": "n_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_v.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_w",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_w(Tensor x, Tensor n) -> Tensor"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_w",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_w.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_w",
    "overload": "x_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_w.x_scalar(Scalar x, Tensor n) -> Tensor"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_w",
    "overload": "x_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:x,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_w.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_w",
    "overload": "n_scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_w.n_scalar(Tensor x, Scalar n) -> Tensor"
  },
  {
    "op": "special_shifted_chebyshev_polynomial_w",
    "overload": "n_scalar_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:n,view_like",
    "schema": "aten::special_shifted_chebyshev_polynomial_w.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_spherical_bessel_j0",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_spherical_bessel_j0(Tensor x) -> Tensor"
  },
  {
    "op": "special_spherical_bessel_j0",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_spherical_bessel_j0.out(Tensor x, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_xlog1py",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_xlog1py(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "special_xlog1py",
    "overload": "other_scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::special_xlog1py.other_scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "special_xlog1py",
    "overload": "self_scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self",
    "schema": "aten::special_xlog1py.self_scalar(Scalar self, Tensor other) -> Tensor"
  },
  {
    "op": "special_xlog1py",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_xlog1py.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_xlog1py",
    "overload": "self_scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self,view_like",
    "schema": "aten::special_xlog1py.self_scalar_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_xlog1py",
    "overload": "other_scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::special_xlog1py.other_scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_zeta",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_zeta(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "special_zeta",
    "overload": "other_scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::special_zeta.other_scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "special_zeta",
    "overload": "self_scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self,view_like",
    "schema": "aten::special_zeta.self_scalar(Scalar self, Tensor other) -> Tensor"
  },
  {
    "op": "special_zeta",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::special_zeta.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_zeta",
    "overload": "self_scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self,view_like",
    "schema": "aten::special_zeta.self_scalar_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "special_zeta",
    "overload": "other_scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::special_zeta.other_scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "split",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::split.Tensor(Tensor(a -> *) self, SymInt split_size, int dim=0) -> Tensor(a)[]"
  },
  {
    "op": "split",
    "overload": "sizes",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:split_size,view_like",
    "schema": "aten::split.sizes(Tensor(a -> *) self, SymInt[] split_size, int dim=0) -> Tensor(a)[]"
  },
  {
    "op": "split",
    "overload": "str",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self|separator,view_like",
    "schema": "aten::split.str(str self, str? separator=None, int max=-1) -> str[]"
  },
  {
    "op": "split",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:split_sizes,view_like",
    "schema": "aten::split(Tensor(a -> *) self, int[] split_sizes, int dim=0) -> Tensor(a)[]"
  },
  {
    "op": "split_with_sizes",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:split_sizes,view_like",
    "schema": "aten::split_with_sizes(Tensor(a -> *) self, SymInt[] split_sizes, int dim=0) -> Tensor(a)[]"
  },
  {
    "op": "split_with_sizes_copy",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:split_sizes,view_like",
    "schema": "aten::split_with_sizes_copy(Tensor self, SymInt[] split_sizes, int dim=0) -> Tensor[]"
  },
  {
    "op": "split_with_sizes_copy",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:split_sizes,view_like",
    "schema": "aten::split_with_sizes_copy.out(Tensor self, SymInt[] split_sizes, int dim=0, *, Tensor(a!)[] out) -> ()"
  },
  {
    "op": "sqrt",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sqrt(Tensor self) -> Tensor"
  },
  {
    "op": "sqrt",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sqrt.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "sqrt",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::sqrt.int(int a) -> float"
  },
  {
    "op": "sqrt",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::sqrt.float(float a) -> float"
  },
  {
    "op": "sqrt",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a,view_like",
    "schema": "aten::sqrt.complex(complex a) -> complex"
  },
  {
    "op": "sqrt",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a,view_like",
    "schema": "aten::sqrt.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "sqrt_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::sqrt_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "square",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::square(Tensor self) -> Tensor"
  },
  {
    "op": "square",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::square.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "square_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::square_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "squeeze",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::squeeze(Tensor(a) self) -> Tensor(a)"
  },
  {
    "op": "squeeze",
    "overload": "dim",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::squeeze.dim(Tensor(a) self, int dim) -> Tensor(a)"
  },
  {
    "op": "squeeze",
    "overload": "dims",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::squeeze.dims(Tensor(a) self, int[] dim) -> Tensor(a)"
  },
  {
    "op": "squeeze",
    "overload": "dimname",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::squeeze.dimname(Tensor(a) self, str dim) -> Tensor(a)"
  },
  {
    "op": "squeeze_copy",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::squeeze_copy(Tensor self) -> Tensor"
  },
  {
    "op": "squeeze_copy",
    "overload": "dim",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::squeeze_copy.dim(Tensor self, int dim) -> Tensor"
  },
  {
    "op": "squeeze_copy",
    "overload": "dims",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::squeeze_copy.dims(Tensor self, int[] dim) -> Tensor"
  },
  {
    "op": "squeeze_copy",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::squeeze_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "squeeze_copy",
    "overload": "dim_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::squeeze_copy.dim_out(Tensor self, int dim, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "squeeze_copy",
    "overload": "dims_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::squeeze_copy.dims_out(Tensor self, int[] dim, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "stack",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::stack(Tensor[] tensors, int dim=0) -> Tensor"
  },
  {
    "op": "stack",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::stack.out(Tensor[] tensors, int dim=0, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "std",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::std(Tensor self, bool unbiased=True) -> Tensor"
  },
  {
    "op": "std",
    "overload": "dim",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::std.dim(Tensor self, int[1]? dim, bool unbiased=True, bool keepdim=False) -> Tensor"
  },
  {
    "op": "std",
    "overload": "correction",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim|correction,view_like",
    "schema": "aten::std.correction(Tensor self, int[1]? dim=None, *, Scalar? correction=None, bool keepdim=False) -> Tensor"
  },
  {
    "op": "std",
    "overload": "names_dim",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::std.names_dim(Tensor self, str[1] dim, bool unbiased=True, bool keepdim=False) -> Tensor"
  },
  {
    "op": "std",
    "overload": "names_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::std.names_out(Tensor self, str[1] dim, bool unbiased=True, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "std",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::std.out(Tensor self, int[1]? dim, bool unbiased=True, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "std",
    "overload": "correction_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim|correction,view_like",
    "schema": "aten::std.correction_out(Tensor self, int[1]? dim=None, *, Scalar? correction=None, bool keepdim=False, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "std",
    "overload": "correction_names",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim|correction,view_like",
    "schema": "aten::std.correction_names(Tensor self, str[1] dim, *, Scalar? correction=None, bool keepdim=False) -> Tensor"
  },
  {
    "op": "std",
    "overload": "correction_names_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim|correction,view_like",
    "schema": "aten::std.correction_names_out(Tensor self, str[1] dim, *, Scalar? correction=None, bool keepdim=False, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "std_mean",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::std_mean(Tensor self, bool unbiased=True) -> (Tensor, Tensor)"
  },
  {
    "op": "std_mean",
    "overload": "dim",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::std_mean.dim(Tensor self, int[1]? dim, bool unbiased=True, bool keepdim=False) -> (Tensor, Tensor)"
  },
  {
    "op": "std_mean",
    "overload": "correction",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim|correction,view_like",
    "schema": "aten::std_mean.correction(Tensor self, int[1]? dim=None, *, Scalar? correction=None, bool keepdim=False) -> (Tensor, Tensor)"
  },
  {
    "op": "std_mean",
    "overload": "names_dim",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::std_mean.names_dim(Tensor self, str[1] dim, bool unbiased=True, bool keepdim=False) -> (Tensor, Tensor)"
  },
  {
    "op": "std_mean",
    "overload": "correction_names",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim|correction,view_like",
    "schema": "aten::std_mean.correction_names(Tensor self, str[1] dim, *, Scalar? correction=None, bool keepdim=False) -> (Tensor, Tensor)"
  },
  {
    "op": "std_mean",
    "overload": "correction_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim|correction,view_like",
    "schema": "aten::std_mean.correction_out(Tensor self, int[1]? dim=None, *, Scalar? correction=None, bool keepdim=False, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))"
  },
  {
    "op": "stft",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:hop_length|win_length|onesided|return_complex|align_to_window,view_like",
    "schema": "aten::stft(Tensor self, int n_fft, int? hop_length=None, int? win_length=None, Tensor? window=None, bool normalized=False, bool? onesided=None, bool? return_complex=None, bool? align_to_window=None) -> Tensor"
  },
  {
    "op": "stft",
    "overload": "center",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:hop_length|win_length|onesided|return_complex|align_to_window,view_like",
    "schema": "aten::stft.center(Tensor self, int n_fft, int? hop_length=None, int? win_length=None, Tensor? window=None, bool center=True, str pad_mode=\"reflect\", bool normalized=False, bool? onesided=None, bool? return_complex=None, bool? align_to_window=None) -> Tensor"
  },
  {
    "op": "storage_offset",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::storage_offset(Tensor self) -> int"
  },
  {
    "op": "stride",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::stride.int(Tensor self, int dim) -> int"
  },
  {
    "op": "stride",
    "overload": "Dimname",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::stride.Dimname(Tensor self, str dim) -> int"
  },
  {
    "op": "stride",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::stride(Tensor self) -> int[]"
  },
  {
    "op": "sub",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sub.Tensor(Tensor self, Tensor other, *, Scalar alpha=1) -> Tensor"
  },
  {
    "op": "sub",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other",
    "schema": "aten::sub.Scalar(Tensor self, Scalar other, Scalar alpha=1) -> Tensor"
  },
  {
    "op": "sub",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sub.out(Tensor self, Tensor other, *, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "sub",
    "overload": "Scalar_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::sub.Scalar_out(Tensor self, Scalar other, Scalar alpha=1, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "sub",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::sub.int(int a, int b) -> int"
  },
  {
    "op": "sub",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b",
    "schema": "aten::sub.complex(complex a, complex b) -> complex"
  },
  {
    "op": "sub",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::sub.float(float a, float b) -> float"
  },
  {
    "op": "sub",
    "overload": "int_complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:b,view_like",
    "schema": "aten::sub.int_complex(int a, complex b) -> complex"
  },
  {
    "op": "sub",
    "overload": "complex_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a,view_like",
    "schema": "aten::sub.complex_int(complex a, int b) -> complex"
  },
  {
    "op": "sub",
    "overload": "float_complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:b,view_like",
    "schema": "aten::sub.float_complex(float a, complex b) -> complex"
  },
  {
    "op": "sub",
    "overload": "complex_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a,view_like",
    "schema": "aten::sub.complex_float(complex a, float b) -> complex"
  },
  {
    "op": "sub",
    "overload": "int_float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::sub.int_float(int a, float b) -> float"
  },
  {
    "op": "sub",
    "overload": "float_int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::sub.float_int(float a, int b) -> float"
  },
  {
    "op": "sub",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a|b,view_like",
    "schema": "aten::sub(Scalar a, Scalar b) -> Scalar"
  },
  {
    "op": "sub_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::sub_.Tensor(Tensor(a!) self, Tensor other, *, Scalar alpha=1) -> Tensor(a!)"
  },
  {
    "op": "sub_",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other",
    "schema": "aten::sub_.Scalar(Tensor(a!) self, Scalar other, Scalar alpha=1) -> Tensor(a!)"
  },
  {
    "op": "subtract",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::subtract.Tensor(Tensor self, Tensor other, *, Scalar alpha=1) -> Tensor"
  },
  {
    "op": "subtract",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::subtract.out(Tensor self, Tensor other, *, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "subtract",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::subtract.Scalar(Tensor self, Scalar other, Scalar alpha=1) -> Tensor"
  },
  {
    "op": "subtract_",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::subtract_.Tensor(Tensor(a!) self, Tensor other, *, Scalar alpha=1) -> Tensor(a!)"
  },
  {
    "op": "subtract_",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other,view_like",
    "schema": "aten::subtract_.Scalar(Tensor(a!) self, Scalar other, Scalar alpha=1) -> Tensor(a!)"
  },
  {
    "op": "sum",
    "overload": "dim_IntList",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dim|dtype,view_like",
    "schema": "aten::sum.dim_IntList(Tensor self, int[1]? dim, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor"
  },
  {
    "op": "sum",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype,view_like",
    "schema": "aten::sum(Tensor self, *, ScalarType? dtype=None) -> Tensor"
  },
  {
    "op": "sum",
    "overload": "dim_DimnameList",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dim|dtype,view_like",
    "schema": "aten::sum.dim_DimnameList(Tensor self, str[1] dim, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor"
  },
  {
    "op": "sum",
    "overload": "DimnameList_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dim|dtype,view_like",
    "schema": "aten::sum.DimnameList_out(Tensor self, str[1] dim, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "sum",
    "overload": "IntList_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dim|dtype,view_like",
    "schema": "aten::sum.IntList_out(Tensor self, int[1]? dim, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "sum",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype,view_like",
    "schema": "aten::sum.out(Tensor self, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "sum",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self,view_like",
    "schema": "aten::sum.int(int[] self) -> int"
  },
  {
    "op": "sum",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self,view_like",
    "schema": "aten::sum.float(float[] self) -> float"
  },
  {
    "op": "sum",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self",
    "schema": "aten::sum.complex(complex[] self) -> complex"
  },
  {
    "op": "sum",
    "overload": "bool",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:self",
    "schema": "aten::sum.bool(bool[] self) -> int"
  },
  {
    "op": "svd",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::svd(Tensor self, bool some=True, bool compute_uv=True) -> (Tensor U, Tensor S, Tensor V)"
  },
  {
    "op": "svd",
    "overload": "U",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready",
    "schema": "aten::svd.U(Tensor self, bool some=True, bool compute_uv=True, *, Tensor(a!) U, Tensor(b!) S, Tensor(c!) V) -> (Tensor(a!) U, Tensor(b!) S, Tensor(c!) V)"
  },
  {
    "op": "sym_constrain_range",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:size|min|max,view_like",
    "schema": "aten::sym_constrain_range(Scalar size, *, int? min=None, int? max=None) -> ()"
  },
  {
    "op": "sym_constrain_range_for_size",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:size|min|max,view_like",
    "schema": "aten::sym_constrain_range_for_size(Scalar size, *, int? min=None, int? max=None) -> ()"
  },
  {
    "op": "sym_numel",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sym_numel(Tensor self) -> SymInt"
  },
  {
    "op": "sym_size",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sym_size.int(Tensor self, int dim) -> SymInt"
  },
  {
    "op": "sym_size",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sym_size(Tensor self) -> SymInt[]"
  },
  {
    "op": "sym_storage_offset",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sym_storage_offset(Tensor self) -> SymInt"
  },
  {
    "op": "sym_stride",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sym_stride.int(Tensor self, int dim) -> SymInt"
  },
  {
    "op": "sym_stride",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::sym_stride(Tensor self) -> SymInt[]"
  },
  {
    "op": "t",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::t(Tensor(a) self) -> Tensor(a)"
  },
  {
    "op": "t_",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::t_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "t_copy",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::t_copy(Tensor self) -> Tensor"
  },
  {
    "op": "t_copy",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::t_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "take",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::take(Tensor self, Tensor index) -> Tensor"
  },
  {
    "op": "take",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::take.out(Tensor self, Tensor index, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "tan",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::tan(Tensor self) -> Tensor"
  },
  {
    "op": "tan",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::tan.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "tan",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::tan.int(int a) -> float"
  },
  {
    "op": "tan",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::tan.float(float a) -> float"
  },
  {
    "op": "tan",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a,view_like",
    "schema": "aten::tan.complex(complex a) -> complex"
  },
  {
    "op": "tan",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a,view_like",
    "schema": "aten::tan.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "tan_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::tan_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "tanh",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::tanh(Tensor self) -> Tensor"
  },
  {
    "op": "tanh",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::tanh.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "tanh",
    "overload": "int",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::tanh.int(int a) -> float"
  },
  {
    "op": "tanh",
    "overload": "float",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_ready,view_like",
    "schema": "aten::tanh.float(float a) -> float"
  },
  {
    "op": "tanh",
    "overload": "complex",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a,view_like",
    "schema": "aten::tanh.complex(complex a) -> complex"
  },
  {
    "op": "tanh",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "unknown",
    "notes": "input_missing:a,view_like",
    "schema": "aten::tanh.Scalar(Scalar a) -> Scalar"
  },
  {
    "op": "tanh_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::tanh_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "tanh_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::tanh_backward(Tensor grad_output, Tensor output) -> Tensor"
  },
  {
    "op": "tanh_backward",
    "overload": "grad_input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::tanh_backward.grad_input(Tensor grad_output, Tensor output, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "tensor_split",
    "overload": "sections",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::tensor_split.sections(Tensor(a -> *) self, SymInt sections, int dim=0) -> Tensor(a)[]"
  },
  {
    "op": "tensor_split",
    "overload": "indices",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:indices,view_like",
    "schema": "aten::tensor_split.indices(Tensor(a -> *) self, SymInt[] indices, int dim=0) -> Tensor(a)[]"
  },
  {
    "op": "tensor_split",
    "overload": "tensor_indices_or_sections",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::tensor_split.tensor_indices_or_sections(Tensor(a -> *) self, Tensor tensor_indices_or_sections, int dim=0) -> Tensor(a)[]"
  },
  {
    "op": "threshold",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:threshold|value,view_like",
    "schema": "aten::threshold(Tensor self, Scalar threshold, Scalar value) -> Tensor"
  },
  {
    "op": "threshold",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:threshold|value,view_like",
    "schema": "aten::threshold.out(Tensor self, Scalar threshold, Scalar value, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "threshold_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:threshold|value,view_like",
    "schema": "aten::threshold_(Tensor(a!) self, Scalar threshold, Scalar value) -> Tensor(a!)"
  },
  {
    "op": "threshold_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:threshold,view_like",
    "schema": "aten::threshold_backward(Tensor grad_output, Tensor self, Scalar threshold) -> Tensor"
  },
  {
    "op": "threshold_backward",
    "overload": "grad_input",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:threshold,view_like",
    "schema": "aten::threshold_backward.grad_input(Tensor grad_output, Tensor self, Scalar threshold, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "to",
    "overload": "device",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:memory_format,view_like",
    "schema": "aten::to.device(Tensor(a) self, Device device, ScalarType dtype, bool non_blocking=False, bool copy=False, MemoryFormat? memory_format=None) -> Tensor(a)"
  },
  {
    "op": "to",
    "overload": "dtype",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:memory_format,view_like",
    "schema": "aten::to.dtype(Tensor(a) self, ScalarType dtype, bool non_blocking=False, bool copy=False, MemoryFormat? memory_format=None) -> Tensor(a)"
  },
  {
    "op": "to",
    "overload": "other",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:memory_format,view_like",
    "schema": "aten::to.other(Tensor(a) self, Tensor other, bool non_blocking=False, bool copy=False, MemoryFormat? memory_format=None) -> Tensor(a)"
  },
  {
    "op": "to",
    "overload": "dtype_layout",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype|layout|pin_memory|memory_format,view_like",
    "schema": "aten::to.dtype_layout(Tensor(a) self, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, bool non_blocking=False, bool copy=False, MemoryFormat? memory_format=None) -> Tensor(a)"
  },
  {
    "op": "to",
    "overload": "prim_Device",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype,prim,view_like",
    "schema": "aten::to.prim_Device(Tensor(a) self, Device? device, int? dtype=None, bool non_blocking=False, bool copy=False) -> Tensor(b|a)"
  },
  {
    "op": "to",
    "overload": "prim_dtype",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype,prim,view_like",
    "schema": "aten::to.prim_dtype(Tensor(a) self, int? dtype=None, bool non_blocking=False, bool copy=False) -> Tensor(b|a)"
  },
  {
    "op": "to",
    "overload": "prim_other",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,prim,view_like",
    "schema": "aten::to.prim_other(Tensor(a) self, bool non_blocking=False, bool copy=False) -> Tensor(b|a)"
  },
  {
    "op": "topk",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::topk(Tensor self, SymInt k, int dim=-1, bool largest=True, bool sorted=True) -> (Tensor values, Tensor indices)"
  },
  {
    "op": "topk",
    "overload": "values",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::topk.values(Tensor self, SymInt k, int dim=-1, bool largest=True, bool sorted=True, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)"
  },
  {
    "op": "trace",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::trace(Tensor self) -> Tensor"
  },
  {
    "op": "trace",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::trace.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "transpose",
    "overload": "int",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::transpose.int(Tensor(a) self, int dim0, int dim1) -> Tensor(a)"
  },
  {
    "op": "transpose",
    "overload": "Dimname",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim0|dim1,view_like",
    "schema": "aten::transpose.Dimname(Tensor(a) self, str dim0, str dim1) -> Tensor(a)"
  },
  {
    "op": "transpose_",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::transpose_(Tensor(a!) self, int dim0, int dim1) -> Tensor(a!)"
  },
  {
    "op": "transpose_copy",
    "overload": "int",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::transpose_copy.int(Tensor self, int dim0, int dim1) -> Tensor"
  },
  {
    "op": "transpose_copy",
    "overload": "int_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::transpose_copy.int_out(Tensor self, int dim0, int dim1, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "triangular_solve",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::triangular_solve(Tensor self, Tensor A, bool upper=True, bool transpose=False, bool unitriangular=False) -> (Tensor solution, Tensor cloned_coefficient)"
  },
  {
    "op": "triangular_solve",
    "overload": "X",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::triangular_solve.X(Tensor self, Tensor A, bool upper=True, bool transpose=False, bool unitriangular=False, *, Tensor(a!) X, Tensor(b!) M) -> (Tensor(a!) solution, Tensor(b!) cloned_coefficient)"
  },
  {
    "op": "tril",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::tril(Tensor self, int diagonal=0) -> Tensor"
  },
  {
    "op": "tril",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::tril.out(Tensor self, int diagonal=0, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "tril_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::tril_(Tensor(a!) self, int diagonal=0) -> Tensor(a!)"
  },
  {
    "op": "tril_indices",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:layout|pin_memory,view_like",
    "schema": "aten::tril_indices(int row, int col, int offset=0, *, ScalarType? dtype=4, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "tril_indices",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::tril_indices.out(int row, int col, int offset=0, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "triu",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::triu(Tensor self, int diagonal=0) -> Tensor"
  },
  {
    "op": "triu",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::triu.out(Tensor self, int diagonal=0, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "triu_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::triu_(Tensor(a!) self, int diagonal=0) -> Tensor(a!)"
  },
  {
    "op": "triu_indices",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:layout|pin_memory,view_like",
    "schema": "aten::triu_indices(int row, int col, int offset=0, *, ScalarType? dtype=4, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "triu_indices",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::triu_indices.out(int row, int col, int offset=0, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "true_divide",
    "overload": "Tensor",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::true_divide.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "true_divide",
    "overload": "Scalar",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::true_divide.Scalar(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "true_divide",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::true_divide.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "true_divide_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::true_divide_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "true_divide_",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other,view_like",
    "schema": "aten::true_divide_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "trunc",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::trunc(Tensor self) -> Tensor"
  },
  {
    "op": "trunc",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::trunc.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "trunc_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::trunc_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "unbind",
    "overload": "int",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::unbind.int(Tensor(a -> *) self, int dim=0) -> Tensor(a)[]"
  },
  {
    "op": "unbind",
    "overload": "Dimname",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::unbind.Dimname(Tensor(a -> *) self, str dim) -> Tensor(a)[]"
  },
  {
    "op": "unbind_copy",
    "overload": "int",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::unbind_copy.int(Tensor self, int dim=0) -> Tensor[]"
  },
  {
    "op": "unbind_copy",
    "overload": "int_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::unbind_copy.int_out(Tensor self, int dim=0, *, Tensor(a!)[] out) -> ()"
  },
  {
    "op": "unfold",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::unfold(Tensor(a) self, int dimension, int size, int step) -> Tensor(a)"
  },
  {
    "op": "unfold_backward",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:input_sizes,view_like",
    "schema": "aten::unfold_backward(Tensor grad_in, SymInt[] input_sizes, int dim, int size, int step) -> Tensor"
  },
  {
    "op": "unfold_backward",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:input_sizes,view_like",
    "schema": "aten::unfold_backward.out(Tensor grad_in, SymInt[] input_sizes, int dim, int size, int step, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "unfold_copy",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::unfold_copy(Tensor self, int dimension, int size, int step) -> Tensor"
  },
  {
    "op": "unfold_copy",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::unfold_copy.out(Tensor self, int dimension, int size, int step, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "uniform",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,view_like",
    "schema": "aten::uniform(Tensor self, float from=0., float to=1., *, Generator? generator=None) -> Tensor"
  },
  {
    "op": "uniform",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:generator,view_like",
    "schema": "aten::uniform.out(Tensor self, float from=0., float to=1., *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "uniform_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:generator,view_like",
    "schema": "aten::uniform_(Tensor(a!) self, float from=0., float to=1., *, Generator? generator=None) -> Tensor(a!)"
  },
  {
    "op": "unique_consecutive",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::unique_consecutive(Tensor self, bool return_inverse=False, bool return_counts=False, int? dim=None) -> (Tensor, Tensor, Tensor)"
  },
  {
    "op": "unique_consecutive",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::unique_consecutive.out(Tensor self, bool return_inverse=False, bool return_counts=False, int? dim=None, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))"
  },
  {
    "op": "unique_dim",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::unique_dim(Tensor self, int dim, bool sorted=True, bool return_inverse=False, bool return_counts=False) -> (Tensor, Tensor, Tensor)"
  },
  {
    "op": "unique_dim",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::unique_dim.out(Tensor self, int dim, bool sorted=True, bool return_inverse=False, bool return_counts=False, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))"
  },
  {
    "op": "unsafe_chunk",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::unsafe_chunk(Tensor self, int chunks, int dim=0) -> Tensor[]"
  },
  {
    "op": "unsafe_split",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::unsafe_split.Tensor(Tensor self, SymInt split_size, int dim=0) -> Tensor[]"
  },
  {
    "op": "unsafe_split",
    "overload": "Tensor_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::unsafe_split.Tensor_out(Tensor self, SymInt split_size, int dim=0, *, Tensor(a!)[] out) -> ()"
  },
  {
    "op": "unsafe_split_with_sizes",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:split_sizes,view_like",
    "schema": "aten::unsafe_split_with_sizes(Tensor self, SymInt[] split_sizes, int dim=0) -> Tensor[]"
  },
  {
    "op": "unsafe_split_with_sizes",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:split_sizes,view_like",
    "schema": "aten::unsafe_split_with_sizes.out(Tensor self, SymInt[] split_sizes, int dim=0, *, Tensor(a!)[] out) -> ()"
  },
  {
    "op": "unsqueeze",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::unsqueeze(Tensor(a) self, int dim) -> Tensor(a)"
  },
  {
    "op": "unsqueeze_",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::unsqueeze_(Tensor(a!) self, int dim) -> Tensor(a!)"
  },
  {
    "op": "unsqueeze_copy",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::unsqueeze_copy(Tensor self, int dim) -> Tensor"
  },
  {
    "op": "unsqueeze_copy",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::unsqueeze_copy.out(Tensor self, int dim, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "upsample_bicubic2d",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|scales_h|scales_w,view_like",
    "schema": "aten::upsample_bicubic2d(Tensor self, SymInt[2] output_size, bool align_corners, float? scales_h=None, float? scales_w=None) -> Tensor"
  },
  {
    "op": "upsample_bicubic2d",
    "overload": "vec",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|scale_factors",
    "schema": "aten::upsample_bicubic2d.vec(Tensor input, SymInt[]? output_size, bool align_corners, float[]? scale_factors) -> Tensor"
  },
  {
    "op": "upsample_bicubic2d",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|scales_h|scales_w,view_like",
    "schema": "aten::upsample_bicubic2d.out(Tensor self, SymInt[2] output_size, bool align_corners, float? scales_h=None, float? scales_w=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "upsample_bilinear2d",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|scales_h|scales_w,view_like",
    "schema": "aten::upsample_bilinear2d(Tensor self, SymInt[2] output_size, bool align_corners, float? scales_h=None, float? scales_w=None) -> Tensor"
  },
  {
    "op": "upsample_bilinear2d",
    "overload": "vec",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|scale_factors",
    "schema": "aten::upsample_bilinear2d.vec(Tensor input, SymInt[]? output_size, bool align_corners, float[]? scale_factors) -> Tensor"
  },
  {
    "op": "upsample_bilinear2d",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|scales_h|scales_w,view_like",
    "schema": "aten::upsample_bilinear2d.out(Tensor self, SymInt[2] output_size, bool align_corners, float? scales_h=None, float? scales_w=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "upsample_bilinear2d",
    "overload": "vec_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|scale_factors,view_like",
    "schema": "aten::upsample_bilinear2d.vec_out(Tensor input, SymInt[]? output_size, bool align_corners, float[]? scale_factors, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "upsample_linear1d",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|scales,view_like",
    "schema": "aten::upsample_linear1d(Tensor self, SymInt[1] output_size, bool align_corners, float? scales=None) -> Tensor"
  },
  {
    "op": "upsample_linear1d",
    "overload": "vec",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|scale_factors",
    "schema": "aten::upsample_linear1d.vec(Tensor input, SymInt[]? output_size, bool align_corners, float[]? scale_factors) -> Tensor"
  },
  {
    "op": "upsample_linear1d",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|scales,view_like",
    "schema": "aten::upsample_linear1d.out(Tensor self, SymInt[1] output_size, bool align_corners, float? scales=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "upsample_nearest1d",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|scales,view_like",
    "schema": "aten::upsample_nearest1d(Tensor self, SymInt[1] output_size, float? scales=None) -> Tensor"
  },
  {
    "op": "upsample_nearest1d",
    "overload": "vec",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|scale_factors,view_like",
    "schema": "aten::upsample_nearest1d.vec(Tensor input, SymInt[]? output_size, float[]? scale_factors) -> Tensor"
  },
  {
    "op": "upsample_nearest1d",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|scales,view_like",
    "schema": "aten::upsample_nearest1d.out(Tensor self, SymInt[1] output_size, float? scales=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "upsample_nearest2d",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|scales_h|scales_w,view_like",
    "schema": "aten::upsample_nearest2d(Tensor self, SymInt[2] output_size, float? scales_h=None, float? scales_w=None) -> Tensor"
  },
  {
    "op": "upsample_nearest2d",
    "overload": "vec",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|scale_factors,view_like",
    "schema": "aten::upsample_nearest2d.vec(Tensor input, SymInt[]? output_size, float[]? scale_factors) -> Tensor"
  },
  {
    "op": "upsample_nearest2d",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|scales_h|scales_w,view_like",
    "schema": "aten::upsample_nearest2d.out(Tensor self, SymInt[2] output_size, float? scales_h=None, float? scales_w=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "upsample_nearest2d",
    "overload": "vec_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|scale_factors,view_like",
    "schema": "aten::upsample_nearest2d.vec_out(Tensor input, SymInt[]? output_size, float[]? scale_factors, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "upsample_nearest2d_backward",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|input_size|scales_h|scales_w,view_like",
    "schema": "aten::upsample_nearest2d_backward(Tensor grad_output, SymInt[2] output_size, SymInt[4] input_size, float? scales_h=None, float? scales_w=None) -> Tensor"
  },
  {
    "op": "upsample_nearest2d_backward",
    "overload": "grad_input",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|input_size|scales_h|scales_w,view_like",
    "schema": "aten::upsample_nearest2d_backward.grad_input(Tensor grad_output, SymInt[2] output_size, SymInt[4] input_size, float? scales_h=None, float? scales_w=None, *, Tensor(a!) grad_input) -> Tensor(a!)"
  },
  {
    "op": "upsample_nearest3d",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|scales_d|scales_h|scales_w,view_like",
    "schema": "aten::upsample_nearest3d(Tensor self, SymInt[3] output_size, float? scales_d=None, float? scales_h=None, float? scales_w=None) -> Tensor"
  },
  {
    "op": "upsample_nearest3d",
    "overload": "vec",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|scale_factors,view_like",
    "schema": "aten::upsample_nearest3d.vec(Tensor input, SymInt[]? output_size, float[]? scale_factors) -> Tensor"
  },
  {
    "op": "upsample_nearest3d",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|scales_d|scales_h|scales_w,view_like",
    "schema": "aten::upsample_nearest3d.out(Tensor self, SymInt[3] output_size, float? scales_d=None, float? scales_h=None, float? scales_w=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "upsample_trilinear3d",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|scales_d|scales_h|scales_w,view_like",
    "schema": "aten::upsample_trilinear3d(Tensor self, SymInt[3] output_size, bool align_corners, float? scales_d=None, float? scales_h=None, float? scales_w=None) -> Tensor"
  },
  {
    "op": "upsample_trilinear3d",
    "overload": "vec",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|scale_factors,view_like",
    "schema": "aten::upsample_trilinear3d.vec(Tensor input, SymInt[]? output_size, bool align_corners, float[]? scale_factors) -> Tensor"
  },
  {
    "op": "upsample_trilinear3d",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:output_size|scales_d|scales_h|scales_w,view_like",
    "schema": "aten::upsample_trilinear3d.out(Tensor self, SymInt[3] output_size, bool align_corners, float? scales_d=None, float? scales_h=None, float? scales_w=None, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "var",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::var(Tensor self, bool unbiased=True) -> Tensor"
  },
  {
    "op": "var",
    "overload": "dim",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::var.dim(Tensor self, int[1]? dim, bool unbiased=True, bool keepdim=False) -> Tensor"
  },
  {
    "op": "var",
    "overload": "correction",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim|correction,view_like",
    "schema": "aten::var.correction(Tensor self, int[1]? dim=None, *, Scalar? correction=None, bool keepdim=False) -> Tensor"
  },
  {
    "op": "var",
    "overload": "names_dim",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::var.names_dim(Tensor self, str[1] dim, bool unbiased=True, bool keepdim=False) -> Tensor"
  },
  {
    "op": "var",
    "overload": "names_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::var.names_out(Tensor self, str[1] dim, bool unbiased=True, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "var",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim,view_like",
    "schema": "aten::var.out(Tensor self, int[1]? dim, bool unbiased=True, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "var",
    "overload": "correction_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim|correction,view_like",
    "schema": "aten::var.correction_out(Tensor self, int[1]? dim=None, *, Scalar? correction=None, bool keepdim=False, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "var",
    "overload": "correction_names",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim|correction,view_like",
    "schema": "aten::var.correction_names(Tensor self, str[1] dim, *, Scalar? correction=None, bool keepdim=False) -> Tensor"
  },
  {
    "op": "var",
    "overload": "correction_names_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim|correction,view_like",
    "schema": "aten::var.correction_names_out(Tensor self, str[1] dim, *, Scalar? correction=None, bool keepdim=False, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "var_mean",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::var_mean(Tensor self, bool unbiased=True) -> (Tensor, Tensor)"
  },
  {
    "op": "var_mean",
    "overload": "dim",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::var_mean.dim(Tensor self, int[1]? dim, bool unbiased=True, bool keepdim=False) -> (Tensor, Tensor)"
  },
  {
    "op": "var_mean",
    "overload": "correction",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim|correction,view_like",
    "schema": "aten::var_mean.correction(Tensor self, int[1]? dim=None, *, Scalar? correction=None, bool keepdim=False) -> (Tensor, Tensor)"
  },
  {
    "op": "var_mean",
    "overload": "names_dim",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim",
    "schema": "aten::var_mean.names_dim(Tensor self, str[1] dim, bool unbiased=True, bool keepdim=False) -> (Tensor, Tensor)"
  },
  {
    "op": "var_mean",
    "overload": "correction_names",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim|correction,view_like",
    "schema": "aten::var_mean.correction_names(Tensor self, str[1] dim, *, Scalar? correction=None, bool keepdim=False) -> (Tensor, Tensor)"
  },
  {
    "op": "var_mean",
    "overload": "correction_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:dim|correction,view_like",
    "schema": "aten::var_mean.correction_out(Tensor self, int[1]? dim=None, *, Scalar? correction=None, bool keepdim=False, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))"
  },
  {
    "op": "vdot",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::vdot(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "vdot",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::vdot.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "view",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size,view_like",
    "schema": "aten::view(Tensor(a) self, SymInt[] size) -> Tensor(a)"
  },
  {
    "op": "view",
    "overload": "dtype",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_ready,view_like",
    "schema": "aten::view.dtype(Tensor(a) self, ScalarType dtype) -> Tensor(a)"
  },
  {
    "op": "view_as_complex",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::view_as_complex(Tensor(a) self) -> Tensor(a)"
  },
  {
    "op": "view_as_real",
    "overload": "default",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::view_as_real(Tensor(a) self) -> Tensor(a)"
  },
  {
    "op": "view_copy",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size,view_like",
    "schema": "aten::view_copy(Tensor self, SymInt[] size) -> Tensor"
  },
  {
    "op": "view_copy",
    "overload": "dtype",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_ready,view_like",
    "schema": "aten::view_copy.dtype(Tensor self, ScalarType dtype) -> Tensor"
  },
  {
    "op": "view_copy",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size,view_like",
    "schema": "aten::view_copy.out(Tensor self, SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "view_copy",
    "overload": "dtype_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_ready,view_like",
    "schema": "aten::view_copy.dtype_out(Tensor self, ScalarType dtype, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "where",
    "overload": "self",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready",
    "schema": "aten::where.self(Tensor condition, Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "where",
    "overload": "ScalarOther",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::where.ScalarOther(Tensor condition, Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "where",
    "overload": "ScalarSelf",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self",
    "schema": "aten::where.ScalarSelf(Tensor condition, Scalar self, Tensor other) -> Tensor"
  },
  {
    "op": "where",
    "overload": "Scalar",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self|other",
    "schema": "aten::where.Scalar(Tensor condition, Scalar self, Scalar other) -> Tensor"
  },
  {
    "op": "where",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::where(Tensor condition) -> Tensor[]"
  },
  {
    "op": "where",
    "overload": "self_out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::where.self_out(Tensor condition, Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "xlogy",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::xlogy.Tensor(Tensor self, Tensor other) -> Tensor"
  },
  {
    "op": "xlogy",
    "overload": "Scalar_Other",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::xlogy.Scalar_Other(Tensor self, Scalar other) -> Tensor"
  },
  {
    "op": "xlogy",
    "overload": "Scalar_Self",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self",
    "schema": "aten::xlogy.Scalar_Self(Scalar self, Tensor other) -> Tensor"
  },
  {
    "op": "xlogy",
    "overload": "OutTensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::xlogy.OutTensor(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "xlogy",
    "overload": "OutScalar_Self",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:self,view_like",
    "schema": "aten::xlogy.OutScalar_Self(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "xlogy",
    "overload": "OutScalar_Other",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:other,view_like",
    "schema": "aten::xlogy.OutScalar_Other(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "xlogy_",
    "overload": "Tensor",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::xlogy_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)"
  },
  {
    "op": "xlogy_",
    "overload": "Scalar_Other",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_missing:other,view_like",
    "schema": "aten::xlogy_.Scalar_Other(Tensor(a!) self, Scalar other) -> Tensor(a!)"
  },
  {
    "op": "zero",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::zero(Tensor self) -> Tensor"
  },
  {
    "op": "zero",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_ready,view_like",
    "schema": "aten::zero.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "zero_",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "inplace,input_ready,view_like",
    "schema": "aten::zero_(Tensor(a!) self) -> Tensor(a!)"
  },
  {
    "op": "zeros",
    "overload": "names",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|names|dtype|layout|pin_memory",
    "schema": "aten::zeros.names(int[] size, *, str[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "zeros",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:size|dtype|layout|pin_memory,view_like",
    "schema": "aten::zeros(SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor"
  },
  {
    "op": "zeros",
    "overload": "names_out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size|names,view_like",
    "schema": "aten::zeros.names_out(int[] size, *, str[]? names, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "zeros",
    "overload": "out",
    "has_decomp": false,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:size,view_like",
    "schema": "aten::zeros.out(SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)"
  },
  {
    "op": "zeros_like",
    "overload": "default",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "by-arg",
    "notes": "input_missing:dtype|layout|pin_memory|memory_format,view_like",
    "schema": "aten::zeros_like(Tensor self, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, MemoryFormat? memory_format=None) -> Tensor"
  },
  {
    "op": "zeros_like",
    "overload": "out",
    "has_decomp": true,
    "devices": "unspecified",
    "dtypes": "tensor",
    "notes": "input_missing:memory_format,view_like",
    "schema": "aten::zeros_like.out(Tensor self, *, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)"
  }
]
